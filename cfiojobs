#!/bin/bash
###########################################################
# Author  : william mei
# Date    : 20181010
# version : cfiojobs0.12.13
# Test platform:
#               kernel     : 3.10.0-514.26.2.el7.x86_64
#               OS release : CentOS 7.3.1611
#               Shell type : GNU Bash-4.2
# description  :
#               send files/command to multy host 
#               parallel fio test on clusters 
# last edit :   20181108
###########################################################

script_version=0.12.31

STATUS=0
function _stop_test(){
if [[ $send_fio == "True" ]]  ;then
    runner=$(whoami)
    # fio test 
    [[ -z ${blk_group_list// /} ]] || \
    for blk_group_name in $ $blk_group_list ;do
        [[ -z ${host_group_list// /} ]] || \
        for host_group_name in $host_group_list ;do
            kill $(ps aux |grep $runner |grep "'--fio'" |grep $blk_group_name |grep $host_group_name |grep -v grep|awk '{print$2}') &>/dev/null
        done
    done && wait 
    # bknd process 
    keywords="fio filename= cal_cpu_mem.sh cal_tcmu_total_iops.sh cal_ceph_bw_iops.sh"
    for kwd in $keywords; do
        kill $(ps aux |grep $runner |grep ssh |grep $kwd |grep -v grep|awk '{print$2}') &>/dev/null
    done
fi
    for i in ${!tmpfile*} ;do eval rm \$"$i" &>/dev/null ;done
}
trap "echo -e '\n job stoped with user signals, stop running, please wait ...'; _stop_test; exit $STATUS" 1 2 3 15
#date=$(date "+%Y-%m-%d_%H:%M:%S")
date="$(date +%Y%m%d%H%M)"
g_conf="$0"".grp"
b_conf="$0"".blk"
j_conf="$0"".job"

##############################################################################################
# Global ARRAY:
# declare golbal arrays to common data storage
# 1. blk group
    # all blk group info will be stored in this union array, keywords $blk_group_name.
    declare -A BLK_DEV_ARRAY 
# 2. job group
    #store all job bs/pattern/args in those union array, common keywords $job_group_name
    declare -A VALID_JOB_INFO_ARRAY \
                  JOB_RUNTIME_ARRAY \
                JOB_DATA_SIZE_ARRAY \
                       JOB_BS_ARRAY \
                  JOB_PATTERN_ARRAY \
                     JOB_ARGS_ARRAY 
#   an index array to store all job batchs.
    declare -a      JOB_BATCH_ARRAY \
                    JOB_BATCH_NAME_ARRAY
# a global variable to store all job batchs
#    JOB_BATCH_LIST=""
# 3. host group
    #store all host group info in those union array, common keywords $host_group_name
    declare -A VALID_HOST_GROUP_INFO_ARRAY \
                     HOST_GROUP_USER_ARRAY \
                     HOST_GROUP_PORT_ARRAY \
                     HOST_GROUP_TCMU_ARRAY \
                     HOST_GROUP_CEPH_ARRAY \
                     HOST_GROUP_IP_LIST_ARRAY 
#
    declare -A       HOST_GROUP_RBD_DEV_ARRAY # host_name 
# a shell array can't contain another array, so set a tmp_delimiter for later access.
#    tmp_delimiter=','
#    OLD_IFS="$IFS"dd
#    tmpfifo=/tmp/tmp."$$"'.fifo'
#
# an output dir list file have all output dir,host group, job group inof stored.
#    echo "" >$0".dirlist"
# temperary history file.
    echo "$(date "+%Y-%m-%d_%H:%M:%S"): $0 $@" >>$0".hst"
##############################################################################################

#help info 
function _show_help_info(){
  echo -e "
This script is a simple fio jobs and file distributor. You can also run commands on multiple hosts with it.
Remenber, you need passwordless SSH access permssions for all hosts, and use a comma as a delimiter when you have multiple group units.

usage :
--------
1. Edit your own host group, block group and fio job type settings in config files.

            (1)     hosts  list conf:   $g_conf
            (2)     blocks list conf:   $b_conf
            (3)     jobs   list conf:   $j_conf

    tips: 

            '$0 -e' will generate example configure files for you

2. Run a short single cmd: 

            $0 <options> [commands]

            options: 
            -t             check host group config file format.
            -g groups      run commands on certain host groups in $g_conf (sep with comma)
            -a             run commands on all host group set
            -x hosts       make an exception on these hosts (sep with comma)
            -X groups      make an exception on these host groups (sep with comma)
            -q             return only exit status of command.(be quiet and less output if no error occurred)
            -d             check and give function parameters, also, skip failure
            -f             skip failure and try to continue, if possible
            -p             send commands and copy files execute in parallel

    Example: 
   
            $0 -q -g grp1,grp2,grp3,grp4 \"systemctl status sshd ;ls abc\" -x 172.18.211.105

    tips:
    say you want run the command:
    
            'ls -i' 

    you can use: 

            $0 ls -i -g vmg1,grp3 -t -d
      
    it is fine, because '-i' does not confilict with any options supported by this script,
    but still we strongly recommend you write it this way:

            $0 \"ls -i\" -g vmg1,grp3 -t -d


3. Example of Some more complex situation. (how to use double/single quote to pass the complete cmd to script):

        (1).with multy command a time:  
            $0  -g <grp name> \"command1 ;  command2 ;  command3 \"

         with command list to run :  
            $0  -g <grp name> \"command1 && command2 || command3 \"

        (2).with pipe thing or some  :  
            $0  -g <grp name> \"your command |pipe |pipe \"

        (3).with local bash variable :  
            $0  -g <grp name> \"your command \$local_variable \"
            
        (4).with remote env variable :  
            $0  -g <grp name> \"your command '\$remote_env_viriable' \" 

    example: 
            
            $0 -g grp1 \"ls -l |awk '{print\\\$2}'\"
         
    or: 

            $0 -g grp1 \"ls -l |awk \\\"{print"'\\''\\\$2'"}\\\"\"
       
    tips: 

            awk variable is not bash shell variable, so there were three antislash inside curly braces,
            first two antislash passed an '\\' to remote bash, and then the third is for translating the '\$'.

4. FIO jobs control
    
            options:
            --fio          launch a fio test
            --fio-list     output summary info of fio jobs on given host groups
            --fio-stop     stop all existinging fio jobs on given host groups (stop a certain round of jobs in test)
            --test-stop    stop test on given host groups (stop all test and all jobs)
            --recover      recover an undone test form where it was interrupted (aborted, killed or cancled)
            --recover-from recover or restart the test form a given \"round number\" (and a certain \"blk group\")
            --round-list   list all job round info with your test options and arguments (launch no test)
            --round-retest retest a batch of fio jobs with a given \"blk group name\" and \"round number\"
                           the round range like: \"6-9\" or: \"blk8,6-9\" are both ok.
            -c             check test env, (network, ssh connections, fio installation, blk dev to test)
            -b             run fio jobs with given blk group in $b_conf
            -j             run fio job with given job group in $j_conf
            -A             fio task 'After' commands that are given
            -E             run the commands everythime fio test batch starts on a host 
            -o             set the output dir for all fio test logs.
            -s             single block mode, one block a time on each host.
            -S             single group mode, one group a time in the test.
            -l             list all running fio jobs info.
            -r             test on rbd blk.

    example: 

            $0 --fio -g grp1 -b vd5,blk8 -j rand1 -o test01 
            $0 --fio-list -g group1 -p
        
    you can have the current round info from script stdout or log file:
    
            \"<output_dir>/recover.log\", 
    you can easyly recover the test with with a certin round point in test progress, say, to recover the previous test with blk 
    target \"blk8\" and round \"6\", you can use the command :         

            $0 --fio -g grp1 -b vd5,file8 -j rand1 --recover-from blk8,6 -o test01 
        
    or recover a test with only one blk group:
    
            $0 --fio -g grp1 -b vd5 -j rand1,mix1 --recover-from 6 -f -o test02 
    
    or recover the test from where you don't know:
    
            $0 --fio -g grp1 -b vd5 -j rand1,mix1 --recover -f -o test02 
    
    note:
        
            when both the commands and fio jobs were running on a given host, they will be execute in parallel,
            but fio jobs will be send first by default, you can use '-A' to let command execute first.
            $0 --fio -g grp1 -b vd5,blk8 -j rand1,mix1 -A \"umount /dev/vdb\" -o grp1_parallel_test01

    tips:

    **remanber to check the test env befor you start your fio test on a group:**
    
            $0 -g <group name> -f -c

5. File distribution

            options:
            -F files       copy files(sep with comma) to remote host
            -C files       collect files(sep with comma) from remote to local host
            -D dir         specify destination directory on remote host

    example: 
    
            $0 -g grp1 -F file1,file2,file3 -D /tmp/180730/ -x 172.18.211.137

6. Help info

            options:
            -h             show this help info
            -e             make examples of config file (when they do not exist)
            -v, --version  show version info
"
}

function _make_conf_example(){
[[ -f $g_conf ]] && echo "host group config file exist." \
 || cat >$g_conf <<EOF
# The IP address delimiter is a coma ','
# tcmu/ceph backend can be an ip address or 'none' 
#
#grp        user    port    tcmu_bknd               ceph_bknd               ip_addr
grp0        root    5000    root,22,172.18.211.132  root,22,172.18.211.62   --     # use $(dirname $0)/conf/grp0.grp as ip list 
grp1        root    22      172.18.211.132          none                    172.18.211.133,172.18.211.134  #running on esxi 

EOF
[[ -f $b_conf ]] && echo "blk group config file exist."  \
 || cat  >$b_conf <<EOF
# 1. Device delimiter is comma ','.
#list_name  lbk_list/file_list 

# example 1:
sd8         /mnt/sdb/data,/mnt/sdc/data,/mnt/sdd/data,/mnt/sde/data,/mnt/sdf/data,/mntsdg/data,/mnt/sdh/data,/mnt/sdi/data

# example 2:
vd5         /dev/sdb,  #some comment
            /dev/sdc,  #loal disk
            /dev/sdd,  #iscsi disk
            /dev/sde,  #ssd
            /dev/sdf

EOF
[[ -f $j_conf ]] && echo "job group config file exist." \
 ||cat  >$j_conf <<EOF 
# 1. fio arguments delimiter is comma ','.
#    If your are using space as a delimiter for fio job arguments, the "job arguments" must be double quoted!
#    Don't use double quote on the field 1~6. 
#
# 2. "DEFAULT" job should be set before any job group with an empty customized options were writen.
#    If 'inherit_DEFAULT' is 'True' all omitted args will be get from the 'DEFAULT' job set.
#    If 'inherit_DEFAULT' is 'False' this job group will use its own fio arguments.
# 3. only 'json' format log is supported . 
#
#job_name   runtime data_size block_size_range read_write_pattern             inherit_DEFAULT  "fio I/O job arguments"
DEFAULT     600     100%      4k,256k,4m       read,randread,write,randwrite  True             "-group_reporting -direct=1 -iodepth=4  -ioengine=libaio -time_based -numjobs=16 --output-format=json"    
test        600     60G       4k,256k,4m       randread,randwrite             True
durable     172800  100%      none             randrw                         False            "-direct=1  -iodepth=32 -numjobs=4 -bssplit=4k/50:256k/40:4m/10 -ioengine=libaio -rwmixwrite=30 -time_based -group_reporting --output-format=json"
EOF
[[ -f $0".iodepth_bs_pattern.csv" ]] && echo $0".iodepth_bs_pattern.csv" exist. \
||cat >$0".iodepth_bs_pattern.csv" <<EOF
,read,randread,write,randwrite
4k,64,64,64,8
256k,64,64,64,4
4m,64,64,4,6
EOF
}


function _red(){
    echo -e "\e[31m$@\e[0m"
}
function _yellow(){
    echo -e "\e[33m$@\e[0m"
}
function _green(){
    echo -e "\e[32m$@\e[0m"
}
function _blue(){
    echo -e "\e[34m$@\e[0m"
}
function _blink(){
    echo -e "\e[5m$@\e[0m"
}
function _uniq_list(){
# go through all the parameters.
    for i in "$@" ;do
        echo $i 
    #return sorted uniq element in one line.
    done |sort -u |sed ':label;N;s/\n/\ /;b label'
}
function _waiting(){
# wait info $1
# sleep time $2
    # head title 
    echo -en "\n  waiting $1 ...    " 
    local t=$2
    until [[ $t -le 1 ]] ;do
        # bar of second 
        for i in '---' ' \ ' ' | ' ' / ' ;do
            # update bar 
            echo -en "\b\b\b$i" 
            sleep 0.25 
        done
        # sec update 
        t=$(($t -1))
        printf  "%-10s" "$t"
        #clean time info 
        printf  "\b\b\b\b\b\b\b\b\b\b"
    done
    # clean waiting 
    echo -en "\r"
    #sleep 5
    #for ((integer = 1; integer <= 5; integer++));do echo -en "\b\b\b" ;done 
    #echo ""
}
function _timeout(){
# another waiting function.
# show timeout info and wait few secends.
    local t="$1"
    #echo -n "time out in :  "
    echo -e "\npress \"Ctrl + c\" to break here."
    until [[ $t -lt 1 ]] ;do 
        t=$(($t - 1))
        printf  "\r\e[33m%-20s\e[0m" "timeout in $t s"
        sleep 1
    done
    echo -e "\r $1 seconds waiting time out, $(_yellow "skip failed and continue.")\n"
}
function _segline(){
    segment="$@"
    local tty_width=$(tput cols)
    local tag_width=$[tty_width/2 -${#segment}/2]
    delimiter=""
    for i in $(seq 1 $tag_width);do delimiter+='-' ;done
    delimiter+="$segment"
    while [[ ${#delimiter} -lt $tty_width ]] ;do delimiter+='-' ;done
    echo -e "\e[34m$delimiter\e[0m"
}
function _unit_time(){
# add time unit to a time value (sec)
    local time_in=$1
        if   [[ $time_in -ge 86400 ]] ;then
            time_out=$(echo $time_in |awk '{printf("%.2f\n",$1/86400)}')"Day(s)"
        elif [[ $time_in -ge 3600 ]] ;then
            time_out=$(echo $time_in |awk '{printf("%.2f\n",$1/3600)}')"Hour(s)"
        elif [[ $time_in -ge 60 ]] ;then
            time_out=$(echo $time_in |awk '{printf("%.2f\n",$1/60)}')"Min(s)"
        elif [[ $time_in -ge 0 ]] ;then
            time_out="$time_in"'(s)'
        elif [[ $time_in -lt 0 ]] ;then
#            time_out="confusion!"
            time_out="overtime!"
        fi
        echo "$time_out"
        unset time_out 
}
function _unquiet(){
# give inof when not quiet mode.
    if [[ $quiet_mode == "True" ]] ;then
        # mute 
        return 1
    else 
        # echo 
        echo -e "$@"
    fi
}
function _tmp_quiet(){
    # $1 on/off  
    [[ $quiet_mode == "True"  ]] && QUIET[global]="True"
    if [[ $1 == "on" ]] ;then
        QUIET[local]="True"
    elif [[ $1 == "off" ]] ;then 
        QUIET[local]="False"
    fi
}
function _local_unquiet(){
    # check local .
    if [[ ${QUIET[local]} == "True" ]] ;then
        # mute 
        return 1
    elif [[ ${QUIET[local]} == "False" ]] ;then 
        # echo
        echo -e "$@"
    #check golbal
    else 
        _unquiet "$@"
    fi
}
function _fifo_empty(){
# check if a pip is read obstructed
if [[ -n $1 ]] ;then
    fifo_name=$1
    line=255
    read line<$fifo_name &
    p_read=$i 
    sleep 0.25
    if ps ax |grep -q ^$p_read  ;then
        echo 255 >$fifo_name &   
        return 0
    else
        return 1
    fi
else
    _red "no fifo name recived!"
fi
}
function _update_check_stat(){
    # add new value to file
    # $1 STAT
    # $2 stat_file
    if [[ -n $2 ]] ;then
        if [[ -f $2 ]] ;then 
            grep -q $1 $2 || echo $1 >>$2
        else
            _verbose "stat file is missing. ${FUNCNAME[@]}"
        fi 
    else
        _verbose "stat file is needed, now it's empty. ${FUNCNAME[@]}"
        # _error_interrupt 
    fi
}
function _error_interrupt(){
#  intterupt script when not debug or no tolerate mode.
#  test with the rest, and wait 3s if need break.
    if [[ $pdebug == "True" ]] ;then
        echo "contunue with test arg \"-d\""
        #wait time out then continue
        _timeout "5"
    elif [[ $tolerate == "True" ]] ;then
        _red "  skip failure and try to continue ..."
    else
    # 2. exit none pdebug
        echo "$(_red " ERROR"): $(date "+%Y-%m-%d_%H:%M:%S"): partially failure occured, script breaks here: $( _yellow "${FUNCNAME[@]:1}")."
        _blue "you can use '-f' or '-d' option to skip the failed part."
        _stop_test && exit 1
    fi
}
# debug tools 
function _marker(){
    _segline "marker $1"
    _blue "function :${FUNCNAME[@]:1}"
}
function _verbose(){
# print info help testing script
# return 1 when pdebug is True
if [[ $pdebug == "True" ]] && [[ -n $1 ]] ;then
    _blue "function :${FUNCNAME[@]:1} \
info:
##############################################"
    infotype=$1
#---------------------------------------------
    if [[ $infotype == "funcinfo" ]]
then
    :
#---------------------------------------------
    elif [[ $infotype == "roundinfo" ]]
then
_blue "\
 NO. JOB ROUND: $job_batch_index 
 arguments set:\n\t $job_batch \n"
#---------------------------------------------
    elif [[ $infotype == "hostinfo" ]]
then
_blue "\
blk group  name: $blk_group_name
job batch round: $job_batch_index
host group name: $current_host_group 
current    host: $host_ip " 
#---------------------------------------------
    elif [[ $infotype == "jobinfo" ]] 
then
_blue"\
send_fio :$send_fio
blk group:$blk_group_name
job group:$job_group_name
hostgroup:$current_host_group
host ip  :$host_ip
outputdir:$output_dir
log_dir  :$log_dir
log_name :$log_name
test_mode:$test_mode
BLK  name:$BLK
##############################################
$fio_cmd \
-filename=$BLK \
-name=$log_name &>$log_dir/$log_name
"
#---------------------------------------------
    elif [[ $infotype == "bkndinfo" ]] 
then
_blue "\
jobgroup : $job_group_name
runtime  : ${JOB_RUNTIME_ARRAY[$job_group_name]}
tcmu log : $tcmu_logfile
ceph log : $ceph_logfile
"
#---------------------------------------------
    elif [[ $infotype == "bknddetail" ]] 
then
_blue "\
bknd: $bknd_user
ip  : $bknd_ip
port: $bknd_port
"
#---------------------------------------------
    elif [[ $infotype == "groupinfo" ]] 
then
_blue "\
blk group: $blk_group_name
job round: $job_batch_index
job group: $job_group_name
job  name: $job_name
fio   cmd: $fio_cmd
host_user: $host_user
host_port: $host_port
tcmu_bknd: ${tcmu_bknd}
ceph_bknd: ${ceph_bknd}
host list: ${ip_list}
"
#---------------------------------------------
# get from job conf file
    elif [[ $infotype == "expansion" ]] 
then
_blue "\
total Round_No:$total_round, 
inner Round_No:${ground[$job_group_name]}, 
batch   detail:
        fio 
        -bs=$BS 
        -rw=$PATTERN 
        -size=${JOB_DATA_SIZE_ARRAY[$job_group_name]} 
        -runtime=${JOB_RUNTIME_ARRAY[$job_group_name]} 
        ${JOB_ARGS_ARRAY[$job_group_name]} 
"
    fi
#---------------------------------------------
_blue "\
##############################################"
else
    [[ $pdebug == "True" ]] && return 0 || return 1
fi
}
#----------------------------------------|continue here |-----------------------
function _record_fail(){
    local failure_stage="" # Round_No precheck list stop check 
    local failure_stat="" # stat fio PATTERN / execute cmd 
    local failure_host="$host_ip"
    local failure_grp="$host_group_name"
    local failure_type="${FUNCNAME[1]}" # parent function name # yum fio blk cmd net ssh 
    local failure_time="$(date +%Y-%m-%d %H:%M:%S)"
    local failure_obj=""  # blk cmd info 
    echo "round_info,$host_ip,host_group_name,PATTERN/execute_mode,${FUNCNAME[1]},$(date +%Y-%m-%d %H:%M:%S),note" >>$output_dir/err.log 
}
function _pingfail(){
    # give unreachable host info
    _red "  host:$host_ip unreachable."
}
function _sshfail(){
    # give ssh connection failed info 
    _red "  host:$host_ip ssh connection failed."
}
function _devfail(){
    [[ -n $blk ]] && local dev_name=$blk || local dev_name=$BLK 
    # give device check failed info 
    _red "  host:$host_ip dev:$dev_name not a valid test device."
}

##############################################################################################
# config file check
##############################################################################################
function _format_conf(){
#transform configfile for most config files
    if [[ -z $1 ]] ;then
        echo "${FUNCNAME[@]}: no config file name recived."
        exit 1
    elif [[ ! -f $1 ]] ;then
        echo "${FUNCNAME[@]}: config file $1 not fond."
        exit 1
    else
        configfile="$1"
    fi
# replace:
    # 1. table with space
    # 2. continuous multiple spaces with one space
# removed:
    # 1. empty line and comment.
    # 2. space/tab in head of line
    # 3. comment in end of line
    # 4. space/tab after a comma 
    # 5. space/tab between comma and the line end '\n'
    # 6. cancle line switch, by remove '\n' after comma
    grep -vE "^$|^#" $configfile \
    |sort -u \
    |sed -e 's/\t\+/\ /g' \
         -e 's/[ ]\+/\ /g' \
         -e 's/^[ ]\+//g' \
         -e 's/^\t\+//g' \
         -e 's/#.*$//g' \
         -e 's/\,[ ]*$/\,/g' \
         -e 's/\,[ ]*/\,/g' \
         -e 's/\,[\t]*$/\,/g' \
         -e 's/\,[\t]*/\,/g' \
    |sed -e ':\,;N;s/\,\n/\,/;b \,'
}
function _check_ip(){
# input : an ip address
    ip="$1"
        #pure number and dot
        if echo $ip |grep -q [^0-9,'.'] ;then
            _stat_check;echo "unknown ip  format: $ip" ;STAT=1 ;check_stat=1
        #not 0 started
        elif echo $ip |grep -q ^0 ;then
            _stat_check;echo "illegal ip  format: $ip" ;STAT=1 ;check_stat=1
        #less than 256
        else 
            for net in $(echo $ip |sed s/\\./\ /g) ;do
                if [[ $net -gt 255 ]] ;then
                    _stat_check;echo "illegal ip  format: $ip" ;STAT=1 ;check_stat=1
                fi
            done
        fi
}
function _check_port(){
# input : a ssh port number
    if echo $1 |grep -q [^0-9] || [[ $1 -ge 65535 ]] ;then
       _stat_check;echo "illegal ssh   port: $1" 
       STAT=1
       check_stat=1
    fi
}
function _check_missing(){
# input : 1 index, 2 content.
    # this array shows the supported check options.
    index_name_array=("host group name" "ssh user" "ssh port" "tcmu backend" "ceph backend" "host ip list")
    # check if content lost.
    if [[ -z $2 ]] ;then
        _stat_check && echo "lost ${index_name_array[$1]} info" 
        STAT=1
        check_stat=1
        continue
    fi
    # different part, different check work.
    if [[ $1 -eq 2 ]] ;then
        _check_port $2
    elif [[ $1 -eq 3 ]] || [[ $1 -eq 4 ]] ;then
        if [[ $2 != "none" ]] ;then
             #check port and ip address.
             echo $2 |grep -q "," && _check_port $(echo $2 |cut -d, -f2)
             _check_ip ${2##*,}
        fi
    elif [[ $1 -eq 5 ]] ;then
        for ip in ${2//,/ } ;do
            _check_ip "$ip"
        done
    fi
}
function _grp_conf_check(){
    function _stat_check(){
        # confirm last time check status.
        # 0, not checked or all fine till the last time, so we know it's the first err on this group, and print the group name with err info.
        # 1, some part already failed, we don't need to reprint the group name.
        [[ $STAT -eq 1 ]] && printf "%-15s" " " || printf "\n%-7s\e[31m%-8s\e[0m" "group:" "$f1, "
    }
    if [ -f $g_conf ] ;then
        #check start.
        dublicated_name=$(_format_conf $g_conf |awk '{print$1}' |uniq -d)
        if [[ -n $dublicated_name ]] ;then
            echo "group name conflicted: $dublicated_name"
        fi
        #echo "$(_format_conf $g_conf)"
        #line_no=0
        #read line with 7 fields
        while read f1 f2 f3 f4 f5 f6 f7
        do
            #line_no=$(($line_no + 1))
            #skip empty line
            #[[ -z ${f1} ]] && continue
            STAT=0
            group_info=($f1 $f2 $f3 $f4 $f5 $f6 $f7)
            for index in {1..5}
            do 
                _check_missing $index ${group_info[$index]}
            done
            if [[ -n $f7 ]] ;then
                _stat_check && echo "unknown extra info: $f7"
            fi
            #echo "group: $f1, username:$f2, port:$f3, tcmu:$f4, ceph:$f5, ipaddr:$f6"
        done  << EOF
$(_format_conf $g_conf)
EOF
        [[ $check_stat -eq 1 ]] && exit $check_stat || echo "host group config file checked ok."
    else
        echo "host list file not fond."
    fi
}
function _blk_conf_check(){
    _blue "${FUNCNAME[@]} is on the way ... 0_="
}
function _job_conf_check(){
    _blue "${FUNCNAME[@]} is on the way ... 0_="
}

##############################################################################################
# user input check
##############################################################################################
#check host,blk,fio jobs list from input
#group name expansion and check

function _get_all_host_group(){
    host_group_list+=$(_format_conf $g_conf \
        |awk '{print$1}' \
        |sed ':label;N;s/\n/\ /;b label'
    )
}
function _host_group_check(){
#veirify all host group from input, then store in array
# grp_stat, 0: ok, 1: part failed, 2: all failed.
    grp_stat=0
    if [[ -n ${host_group_list} ]] ;then
        host_group_list=$(_uniq_list $host_group_list)
        #calculating group name and ip list
        # remove exceptions
        if [[ -n $x_group_list ]] ;then
            x_group_list=$(_uniq_list $x_group_list)
            for x_group in $x_group_list ;do
                host_group_list=${host_group_list/$x_group/}
            done
        fi
        index_name_array=("host group name" "ssh user" "ssh port" "tcmu backend" "ceph backend" "host ip list")
    #check group result after remove X group
        if [[ -n ${host_group_list// /} ]] ;then
            #validate every host group availability
            for host_group_name in ${host_group_list} ;do 
            #get group info from conf file with keywords in column one.
            group_info=($(_format_conf $g_conf |grep ^$host_group_name[' '] ))
            # 1. group_info check, more then 4 culumns, 
            if [[ ${#group_info[@]} -gt 5 ]] ;then
            # 2. if no missing columns, store into global array
                   VALID_HOST_GROUP_INFO_ARRAY[$host_group_name]=${group_info[@]}
                         HOST_GROUP_USER_ARRAY[$host_group_name]=${group_info[1]}
                         HOST_GROUP_PORT_ARRAY[$host_group_name]=${group_info[2]}
                         HOST_GROUP_TCMU_ARRAY[$host_group_name]=${group_info[3]}
                         HOST_GROUP_CEPH_ARRAY[$host_group_name]=${group_info[4]}
                # find ip list in config dir "conf/xxx.grp"
                if [[ ${group_info[5]} == '--' ]] ;then
                    local host_conf=$(dirname $0)/conf/$host_group_name".grp"
                    if [[ -f $host_conf ]] ;then
                        HOST_GROUP_IP_LIST_ARRAY[$host_group_name]=$(_uniq_list $(_format_conf $host_conf ))
                    else
                        echo "Warning: host group config file: $j_conf, group name: \"$host_group_name\" , ip list file: \"$host_conf\" is missing "
                    fi
                else
                      HOST_GROUP_IP_LIST_ARRAY[$host_group_name]=$(_uniq_list ${group_info[5]//,/ })
                fi
#echo ${HOST_GROUP_IP_LIST_ARRAY[$host_group_name]}
            else
            # if group info lost, skip or exit
            # 3. check from last, find last missing info index, and print its name.
                for index in {1..5} ;do
                   [[ -z ${group_info[$index]} ]] && echo "Warning: host group config file: $j_conf, group name: \"$host_group_name\" , ${index_name_array[$index]} info missing!"
                done
                grp_stat=1
                # remove from host_group_list
                host_group_list=${host_group_list/$host_group_name/}
                _error_interrupt
            fi
            #group check done
            done
            #after group check, if valid host group exists
            if [[ -z ${host_group_list// /} ]] ;then
                grp_stat=2
                echo "no valid host group!"
            fi
        else
        #no valid group left after remove X group
            _red "no valid host group!"
            grp_stat=2
        fi
    else
    #no group input captured
        grp_stat=2
        _red "no host group name revived."
        exit 1
    fi
}
function _job_group_check(){
#verify job group and get fio arguments merged, then store in array
# job_stat, 0: ok, 1: part failed, 2: all failed.
    job_stat="0"
    #get default job info array
    DEFAULT_INFO=($(_format_conf $j_conf |grep ^DEFAULT[' '] ))
        #check args were double quoted
        [[ ${DEFAULT_INFO[6]} =~ '"' ]] && \
        DEFAULT_INFO[6]=$(_format_conf $j_conf |grep ^DEFAULT[' '] |cut -d'"' -f2) || \
        DEFAULT_INFO[6]="${DEFAULT_INFO[6]//,/ }"
    #an array of element names for all job group
    index_name_array=("job group name" "job runtime" "test data size" "block size" "test pattern" "inherit_DEFAULT" "customized fio args")
    #list checking work
    if [[ -n ${job_group_list} ]] ;then
        job_group_list=$(_uniq_list $job_group_list)
        # 01 every job group, info check.
        for job_group_name in $job_group_list ;do
            # get its info
            if _format_conf $j_conf | grep -q ^$job_group_name[' '] ;then
                :
            else
                # skip invalid
                job_group_list=${job_group_list//$job_group_name/}
                continue
            fi
            job_group_info=($(_format_conf $j_conf |grep ^$job_group_name[' '] ))
                #check args were double quoted
                [[ ${job_group_info[6]} =~ '"' ]] && \
                job_group_info[6]=$(_format_conf $j_conf |grep ^$job_group_name[' '] |cut -d'"' -f2) || \
                job_group_info[6]="${job_group_info[6]//,/ }"
            # 1. job group info must more than 6 element, index 0-5.
            if [[ ${#job_group_info[@]} -lt 6 ]] ;then
                # check failed, remove it from blk group list, update grp_stat
                job_stat=1
                job_group_list=${job_group_list/$job_group_name/}
                # check missing array element. check from the last, which element is missing.
                # if index2 is missing index3 will be take as index2, so always find the last missing index, index 1-5
                for index in {1..5} ;do
                   [[ -z ${job_group_info[$index]} ]] && echo "Warning: job group config file: $j_conf, $job_group_name: ${index_name_array[$index]} info missing!"
                done
                _error_interrupt
            else
            # 2. if info ok, args calculating, check if use default
                # if use default, merge default fio args
                if [[ ${job_group_info[5]} == "True" ]] ;then 
                    # DEFAULT arg iterm check and add to this job group
                    for iterm in ${DEFAULT_INFO[6]} ;do
                        [[ "${job_group_info[6]}" =~ "${iterm%%=*}" ]] || job_group_info[6]+=" ${iterm}"
                    done
                # if not use default, doing nothing, just keep its own.
                fi
            # 3. after calculation, save valid group info to global arrays for common access
               VALID_JOB_INFO_ARRAY[$job_group_name]="${job_group_info[@]:0:7}"
                  JOB_RUNTIME_ARRAY[$job_group_name]="${job_group_info[1]}"
                JOB_DATA_SIZE_ARRAY[$job_group_name]="${job_group_info[2]}"
                       JOB_BS_ARRAY[$job_group_name]="${job_group_info[3]//,/ }"
                  JOB_PATTERN_ARRAY[$job_group_name]="${job_group_info[4]//,/ }"
                     JOB_ARGS_ARRAY[$job_group_name]="${job_group_info[6]}"
            fi
            # options should be started with '-'
            for iterm in ${job_group_info[6]} ;do
                [[ ${iterm:0:1} != '-' ]] && _yellow "job group name: $job_group_name, loose fio option found: \"${iterm}\"" && _timeout 15
            done
        #   04 exit or skip if any job group info missing.
                job_stat="1"
        #  group check done
        done
    #   after group check, if valid job groups exists
        if [[ -z ${job_group_list// /} ]] ;then
            job_stat="2"
            _red "no valid job group!"
            exit 1
        fi
        [[ $(echo $job_group_list |wc -w) -gt 1 ]] && multy_job_group="True"
    #
    else
        job_stat="2"
        _red "No job group name recived."
        exit 1
    fi
}
function _blk_group_check(){
#verify blk group from input, then store in array
# blk_stat, 0: ok, 1: part failed, 2: all failed.
    blk_stat="0"
    #none empty list
    if [[ -n ${blk_group_list// /} ]];then
        blk_group_list=$(_uniq_list $blk_group_list)

        # every blk, group info check
        for blk_group_name in $blk_group_list ;do
            # 1. if found in conf
#echo "check result"
#_format_conf $b_conf 
#_format_conf $b_conf |grep ^$blk_group_name[' ']
#echo "pre check result"
#_format_conf $b_conf |grep ^[' ']*$blk_group_name[' ']
#sleep 30
            if _format_conf $b_conf |grep -q ^[' ']*$blk_group_name[' '] ;then
            # 2. device list existence
                #get blk_list info put in a array
                blk_group_info=($(_format_conf $b_conf |grep ^$blk_group_name[' '] ))
#echo "${blk_group_info[@]}"
                if [[ -z ${blk_group_info[1]} ]] ;then
                    #no device list, remove from blk group list, update blk group stat
                    blk_stat="1"
                    blk_group_list=${blk_group_list/$blk_group_name/}
                    # give info which is missing.
                    echo "blk group: $blk_group_name, device list info is missing!"
                    # if test with the rest group
                    _error_interrupt
                else
            # 3. after check no part missing, store device list of this blk group in global array.
                BLK_DEV_ARRAY[$blk_group_name]=${blk_group_info[1]//,/ }
                fi
            elif [[ -f $(dirname $0)/conf/$blk_group_name".blk" ]] ;then
                # check blk config and add blk info to array 
                blk_group_info[1]=$(_format_conf $(dirname $0)/conf/$blk_group_name".blk")
                blk_group_info[1]=$(_uniq_list ${blk_group_info[1]})
                [[ -n ${blk_group_info[1]//,/} ]] && BLK_DEV_ARRAY[$blk_group_name]=${blk_group_info[1]//,/ }
            # 1.2 name missing in conf
            else
            #remove the invalid group which its name not exist in conf
                echo "Warning: blk config file: $b_conf, $blk_group_name: device list info is missing!"
                blk_stat="1"
                blk_group_list=${blk_group_list/$blk_group_name/}
                # skip missing test with the rest group
                _error_interrupt
            fi
            #sleep 30
        #check done
        done
        # after all checked, if available blk_group exist
        if [[ -z ${blk_group_list// /} ]] ;then
            blk_stat="2"
            _red "no valid blk groups."
        fi
        [[ $(echo $blk_group_list |wc -w) -gt 1 ]] && multy_blk_group="True"
    else
    #empty list
    #[[ -f $(dirname $0)/conf/ ]]
        #if [[ $no_sys_blk != "True" ]] ;then
            blk_stat="2"
            _red "no blk group name recived."
            exit 1
        #fi
    fi
}
function _recover_point_check(){
    # confilict check.
    [[ $recover_test == "True" ]] && [[ $round_retest == "True" ]] && echo "Parameter confusion!" && exit 1
# recover or retest.
if  [[ $recover_test == "True" ]] || [[ $round_retest == "True" ]] ;then 
    if [[ $recover_test == "True" ]] ;then
        # recover_blk_group_name might be empty 
        # recover_job_batch_index cannot be empty 
        if [[ -z $recover_job_batch_index ]] ;then
            # check recover log file 
            if [[ ! -f $output_dir/recover.log ]] ;then
                _yellow "Recover log file: \"$output_dir/recover.log\" is missing!"
                echo "Perhapes the test ended too early or it's all done, You can restart the test but it cant't be recovered."
                exit 1
            fi
            recover_info=$(sed -n 1p $output_dir/recover.log)
            recover_blk_group_name=${recover_info%,*}
            recover_job_batch_index=${recover_info##*,}
        fi
        # give recover info 
        _blue "Test recovering..."
    elif [[ $round_retest == "True" ]] ;then 
        _blue "Round retest starting..."
    fi
    # check format and give info 
    if [[ ${recover_job_batch_index//[^0-9,-]/} != $recover_job_batch_index ]] ;then
        echo "$recover_job_batch_index: recover_job_batch_index format error!"
        exit 1
    fi
    [[ -z $recover_blk_group_name ]] && local b_name="omited" || local b_name=\"$recover_blk_group_name\"
    _blue "recover point: blk_group_name: $b_name, job_batch_index: \"$recover_job_batch_index\""
fi 
}
function _recover_blk_group(){
                # recover 
                [[ $recover_test == "True" ]] && [[ -n $recover_blk_group_name ]] && [[ $blk_group_name != $recover_blk_group_name ]] && continue 
                # clean recover info after recovery
                [[ $recover_test == "True" ]] && recover_blk_group_name=""
                #_blue "recover from blk group: $blk_group_name"

                # round retest 
                [[ $round_retest == "True" ]] && [[ -n $recover_blk_group_name ]] && [[ $blk_group_name != $recover_blk_group_name ]] && continue 
}
function _recover_job_batch(){
                # recover  
                [[ $recover_test == "True" ]] && [[ -n $recover_job_batch_index ]] && [[ $job_batch_index != $recover_job_batch_index ]] && continue 
                # clean recover info after recovery
                [[ $recover_test == "True" ]] && recover_job_batch_index="" && recover_test="False"
                # set new recover_info 
                echo "$blk_group_name,$job_batch_index" > $output_dir/recover.log
                #_blue "recover test batch from job Round_No: $job_batch_index"

                # round retest 
            if [[ ${recover_job_batch_index/-/} == ${recover_job_batch_index} ]] ;then 
                [[ $round_retest == "True" ]] && [[ -n $recover_job_batch_index ]] && [[ $job_batch_index != $recover_job_batch_index ]] && continue 
            else 
                [[ $round_retest == "True" ]] && [[ -n $recover_job_batch_index ]] && [[ $job_batch_index -lt ${recover_job_batch_index%-*} ]] && continue 
                [[ $round_retest == "True" ]] && [[ -n $recover_job_batch_index ]] && [[ $job_batch_index -gt ${recover_job_batch_index#*-} ]] && continue 
            fi 
}
##############################################################################################
# task preparation.
##############################################################################################
# 1. a blk group can not be shared for different scale of fio test at the same time,
#    but the job groups and the host groups can be shared by different scale of test.
# 2. build a job batch list with all available job groups, contains each round of job.
# 3. distribute jobs to host groups, different host groups may have different user and port settings
function _rbd_expansion(){
    # $1 host_group_name 
    # $blk_group_name set 
    local all_ip_list=''
    if [[ -z $1 ]] ;then
        for i in $host_group_list;do
            all_ip_list+=" ${HOST_GROUP_IP_LIST_ARRAY[$i]}"
        done
    else
        all_ip_list="${HOST_GROUP_IP_LIST_ARRAY[$1]}"
    fi 
    all_ip_list=$(_uniq_list $all_ip_list)
    # HOST_GROUP_IP_LIST_ARRAY
    # HOST_GROUP_RBD_DEV_ARRAY 
    # cleanning up array for current host group 
# if an array declared in a function, it will a local array for bash shell.
    #unset HOST_GROUP_RBD_DEV_ARRAY 
    #declare -A HOST_GROUP_RBD_DEV_ARRAY # host_name 
    for k in ${HOST_GROUP_RBD_DEV_ARRAY[*]};do
        [[ -n $k ]] && HOST_GROUP_RBD_DEV_ARRAY[$k]=''
    done
    local rbd_list=${BLK_DEV_ARRAY[$blk_group_name]} 
    #local hst_list=${HOST_GROUP_IP_LIST_ARRAY[$1]}
    # count rbd_numbere
    local rbd_nu=$(echo $rbd_list |wc -w)
    # count host number 
    #local hst_nu=$(echo $hst_list |wc -w)
    local hst_nu=$(echo $all_ip_list |wc -w)
    # 
    if [[ $hst_nu -ge $rbd_nu ]] ;then 
        # rbd less then host 
        local dsb_nu=1
    else
        local dsb_nu=$(($rbd_nu / $hst_nu))
    fi
    # 
    #echo "rbd:$rbd_nu hst:$hst_nu dsb:$dsb_nu"
    local host_name=''
    for host_name in $all_ip_list ;do
        HOST_GROUP_RBD_DEV_ARRAY[$host_name]=''
    done
    for host_name in $all_ip_list ;do
        #echo "host: $host_name"
        for rbd_name in $rbd_list ;do
            # rbd001 
            #echo "rbd: $rbd_name hst rbd nu:$(echo ${HOST_GROUP_RBD_DEV_ARRAY[$host_name]} |wc -w)"
            if test $(echo ${HOST_GROUP_RBD_DEV_ARRAY[$host_name]} |wc -w) -lt $dsb_nu ;then 
                HOST_GROUP_RBD_DEV_ARRAY[$host_name]+=" $rbd_name" 
                rbd_list=${rbd_list/$rbd_name/}
            else
                break 
            fi
        done
    done
    if [[ $(( $rbd_nu % $hst_nu )) -ne 0 ]];then
        #
        for host_name in $all_ip_list;do
            #
            for rbd_name in $rbd_list ;do
                HOST_GROUP_RBD_DEV_ARRAY[$host_name]+=" $rbd_name" 
                rbd_list=${rbd_list/$rbd_name/}
                break 
            done
        done
    fi
    if _verbose || [[ $round_list == "True" ]] ;then 
        if [[ -n $1 ]] ;then 
            local i="host group: $host_group_name" 
        else
            #_blue "\ngroup parallel test expansion"
            local i="host groups: ${host_group_list// /, }" 
        fi 
        _yellow "\nRBD Distribution Info:"
        _blue "blk group: $blk_group_name, $i"
#echo keys: ${!HOST_GROUP_RBD_DEV_ARRAY[*]}
#echo host: $all_ip_list
        for k in ${all_ip_list};do
            printf "%-24s%-15s\n" "host: ${k}" "| ${HOST_GROUP_RBD_DEV_ARRAY[$k]}"
        done
        echo ''
    fi
}
function _show_rbd_expansion(){
    #test _rbd_expansion 
    if [[ $rbd_mode == "True" ]] ;then 
        if [[ $group_mode == "single" ]];then
            for blk_group_name in $blk_group_list;do 
                for host_group_name in $host_group_list;do
                    _rbd_expansion $host_group_name 
                done
            done
        else
            _rbd_expansion 
        fi
    fi 
}
function _get_iodepth_from_table(){
    _blue "${FUNCNAME[@]} is on the way ... 0_=" && exit 1
# get iodepth from a table with bs and pattern axis.
    iodepth_bs_pattern_table="$1"
    [[ ! -f "$iodepth_bs_pattern_table" ]] \
     && echo "$(date "+%Y-%m-%d_%H:%M:%S") ${FUNCNAME[@]} $iodepth_bs_pattern_table not fond !" \
     && exit 1
    declare -A col_no
    col_no[read]=2
    col_no[randread]=3
    col_no[write]=4
    col_no[randwrite]=5
    colume=${col_no[$PATTERN]}
#give iodepth from table
    IODEPTH=$(grep $BS $iodepth_bs_pattern_table |cut -d',' -f $colume)
    echo "$IODEPTH"
}
function _give_size(){
    if [[ ${JOB_DATA_SIZE_ARRAY[$job_group_name]} != "none" ]] ;then
        echo "-size=${JOB_DATA_SIZE_ARRAY[$job_group_name]}"
    #else
    #    :
    fi
}
function _give_bs(){
    if [[ $BS != "none" ]] ;then
        echo "-bs=$BS"
    #else
    #    :
    fi
}
function _fio_job_expansion(){
# generate job batch for blk group to build scale test, and send to  host group to execute.
# expanted based on: job_group_name --> BS --> PATTERN 
#                    they will be stored in a global name array.
    total_round=0
    local runtime_sum=""
    declare -A ground gtime
    _verbose && _yellow "job group expansion:"
    for job_group_name in $job_group_list ;do
        #count round number and basic time costs for group.
        ground[$job_group_name]=0
        gtime[$job_group_name]=0
#        echo ${VALID_JOB_INFO_ARRAY[$job_group_name]}
        for BS in ${JOB_BS_ARRAY[$job_group_name]} ;do
            for PATTERN in ${JOB_PATTERN_ARRAY[$job_group_name]} ;do
                #update round number
                total_round=$(($total_round + 1))
                ground[$job_group_name]=$(( ${ground[$job_group_name]} + 1 ))
                #update time for group
                gtime[$job_group_name]=$(( ${JOB_RUNTIME_ARRAY[$job_group_name]} * ${ground[$job_group_name]} / 60 )) 
                #update runtime_sum
                [[ -z $runtime_sum ]] && runtime_sum=${JOB_RUNTIME_ARRAY[$job_group_name]}  || runtime_sum=$((${JOB_RUNTIME_ARRAY[$job_group_name]} + $runtime_sum ))
                #pdebug info
                _verbose "expansion" && _waiting "reading" 5
                #store job batch in global list
                JOB_BATCH_ARRAY[$total_round]="\
fio \
$(_give_bs) \
$(_give_size) \
-rw=$PATTERN \
-runtime=${JOB_RUNTIME_ARRAY[$job_group_name]} \
${JOB_ARGS_ARRAY[$job_group_name]} "
                JOB_BATCH_NAME_ARRAY[$total_round]=$job_group_name-$BS-$PATTERN
            done
        done
    done
    # round info 
    if _verbose || [[ $round_list == "True" ]] ;then 
        _yellow "job time caculation:"
        echo -e "\tall job group will lunch $total_round fio jobs, and costs $(($runtime_sum / 60 + $(($total_round/ 2)) )) minites on a single host at least.\n"
        for job_group_name in $job_group_list ;do
            echo -e "\tjob group: \"$job_group_name\" will lunch ${ground[$job_group_name]} round of jobs, costs $((${gtime[$job_group_name]} + $((${ground[$job_group_name]}/2)) )) minites at least."
        done
        # make a list of job batch info 
        local tmpfile_expansion=$(mktemp)
        local title="NO"
        local batch="PATTERN"
        for index in $(seq 1 $total_round);do
            #
            title+=",$index"
            batch+=",${JOB_BATCH_NAME_ARRAY[$index]}"
        done
        echo -e "$title\n$batch" >$tmpfile_expansion 
        _yellow "round list:"
        $(dirname $0)/catcsv.sh $tmpfile_expansion | sed 1d 
        rm -f $tmpfile_expansion 
        [[ $round_list == "True" ]] && _show_rbd_expansion && exit 0 || _waiting "reading" 5
    fi
}
##############################################################################################
# cluster test action decomposition
##############################################################################################
# this part function by assigning different tasks to different individuals
function _parse_host_info(){
# input : host_group_name
# parsing from global array 
#     host_user, host_port, ip_list,
#     fio_cmd, 
#     job_group_name bs pattern 
    if [[ -z $1 ]] ;then
        if [[ -n $host_group_name ]] ;then
            current_host_group="$host_group_name"
        else
            echo "${FUNCNAME[@]} : no host group name recived"
            continue
        fi
    else
        current_host_group="$1"
        host_user="${HOST_GROUP_USER_ARRAY[$current_host_group]}"
        host_port="${HOST_GROUP_PORT_ARRAY[$current_host_group]}"
        tcmu_bknd="${HOST_GROUP_TCMU_ARRAY[$current_host_group]}"
        ceph_bknd="${HOST_GROUP_CEPH_ARRAY[$current_host_group]}"
          ip_list="${HOST_GROUP_IP_LIST_ARRAY[$current_host_group]}"
#echo $ip_list
          fio_cmd="${job_batch}"
         num_jobs=$(echo $fio_cmd |awk -F'-numjobs=' '{print$2}' |awk '{print$1}')
         [[ -z $num_jobs ]] && num_jobs=x
   job_group_name="${JOB_BATCH_NAME_ARRAY[$job_batch_index]%%-*}"
         job_name="${JOB_BATCH_NAME_ARRAY[$job_batch_index]#*-}"
        # give info
        echo " host group : $(_yellow "$current_host_group") $(_local_unquiet "  host amount: $(echo $ip_list |wc -w) ") "
        #[[ -n $blk_group_name ]] && _unquiet " blk group:\"$blk_group_name\",job batch num:\"$job_batch_index\",job group name:\"$job_group_name\",job pattern:\"$job_name\""
        if [[ -n $blk_group_name ]] ;then 
            [[ -n $job_group_name ]] && local parse_runtime_info="runtime: ${JOB_RUNTIME_ARRAY[$job_group_name]}"
            _local_unquiet " blk group:\"$blk_group_name\",  blk amount:\"$(echo ${BLK_DEV_ARRAY[$blk_group_name]} |wc -w )\",  blk test mode: $(_yellow $test_mode)"
            _local_unquiet " job group:\"$job_group_name\",  job pattern:\"$job_name\",  $parse_runtime_info "
            #echo ${!JOB_RUNTIME_ARRAY[@]}
            #echo $job_group_name 
        fi
        if [[ -z ${host_user// /} ]] || [[ -z ${host_port// /} ]] || [[ -z ${ip_list// /} ]] ;then
            echo "${FUNCNAME[@]}: group: \"$1\", ssh login info is missing."
            continue || exit 1
        fi
        #remove x_host list from group ip_list
        if [[ -n $x_host_list ]] ;then
            for xh in $x_host_list ;do
                ip_list=${ip_list/$xh/}
            done
        fi
        # info
        if _verbose "groupinfo" ;then
            _waiting "reading" 5
            if [[ $send_fio == "True" ]] && [[ -n $blk_group_name ]] ;then
                echo "blk list : ${BLK_DEV_ARRAY[$blk_group_name]}"
                _waiting "reading blk info" 5
            fi
        fi
    fi
}
##############################################################################################
# actions on a host
##############################################################################################
function _ssh_send(){
#send command info to host when ssh_user, ssh_ip, ssh_port was set
    if [[ $# -lt 1 ]] ;then
        echo "${FUNCNAME[@]} warning: no command info to send!" 
        continue
    else
        #ssh -n -t -q -o StrictHostKeyChecking=no -o ConnectTimeout=15 -l $host_user $host_ip -p $host_port "$@"
        ssh -n -q -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o PubkeyAuthentication=yes -o PasswordAuthentication=no -l $host_user $host_ip -p $host_port "$@"
        #expect -v &>/dev/null && expect bin/expect_ssh2vm.exp $host_user $host_ip $host_port $host_pwd "$@"
    fi
}
function _send_file(){
if [[ -n $file_group_list ]] ;then
    _unquiet "  $host_ip send files..."
    if [[ $quiet_mode == "True" ]] ;then
        scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o PubkeyAuthentication=yes -o PasswordAuthentication=no -P $host_port $file_group_list $host_user@$host_ip:$file_group_destination &>/dev/null 
        local scp_stat=$?
        echo "  $host_ip stat: $scp_stat"
        _update_check_stat $scp_stat $tmpfile_exec 
    else
        scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o PubkeyAuthentication=yes -o PasswordAuthentication=no -P $host_port $file_group_list $host_user@$host_ip:$file_group_destination && echo "  $host_ip done"
        local scp_stat=$?
        _update_check_stat $scp_stat $tmpfile_exec 
    fi
#else
#    [[ $send_fio == "True" ]] && _unquiet "    no files to copy."
fi
}
function _harvest_file(){
if [[ -n ${harvest_file_group_list//,/} ]] ;then
    _check_output_dir
    local harvest_dir=$output_dir/$host_ip
    [[ -d $harvest_dir ]] || mkdir -p $harvest_dir &>/dev/null
    _unquiet "  $host_ip harvest files..."
    # one file or dir to harvest
    if [[ ${harvest_file_group_list//,/} == ${harvest_file_group_list} ]] ;then
        if [[ $quiet_mode == "True" ]] ;then
            eval scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=15 -P $host_port $host_user@$host_ip:$harvest_file_group_list $harvest_dir/ &>/dev/null                                                        
            local hvst_stat=$?
            echo "  $host_ip stat: $hvst_stat"
            _update_check_stat $hvst_stat $tmpfile_exec 
        else
            eval scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o PubkeyAuthentication=yes -o PasswordAuthentication=no -P $host_port $host_user@$host_ip:$harvest_file_group_list $harvest_dir && echo "  $host_ip done"
            local hvst_stat=$?
            _update_check_stat $hvst_stat $tmpfile_exec 
        fi
    # multy files
    else
        if [[ $quiet_mode == "True" ]] ;then
            eval scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o PubkeyAuthentication=yes -o PasswordAuthentication=no -P $host_port $host_user@$host_ip:{$harvest_file_group_list} $harvest_dir/ &>/dev/null                                                        
            local hvst_stat=$?
            echo "  $host_ip stat: $hvst_stat"
            _update_check_stat $hvst_stat $tmpfile_exec 
        else
            eval scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o PubkeyAuthentication=yes -o PasswordAuthentication=no -P $host_port $host_user@$host_ip:{$harvest_file_group_list} $harvest_dir && echo "  $host_ip done"
            local hvst_stat=$?
            _update_check_stat $hvst_stat $tmpfile_exec 
        fi
    fi
#else
#    [[ $send_fio == "True" ]] && _unquiet "    no files to copy."
fi
}
function _send_cmd(){
#send cmd to host and format output.
if [[ -n $CMD ]] ;then
    if [[ $quiet_mode == "True" ]] ;then
        _ssh_send "$CMD " &>/dev/null 
        local cmd_stat=$?
        echo "  $host_ip stat: $cmd_stat"
        _update_check_stat $cmd_stat $tmpfile_exec 
    elif  [[ $p_exec == "True" ]] ;then 
        tmpfile_exec_host_out=$(mktemp)
        #use virtual terminal and recive tty input.
        # echo "$host_ip :"
        ssh -t -q -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o PubkeyAuthentication=yes -o PasswordAuthentication=no -l $host_user $host_ip -p $host_port "$CMD" &>$tmpfile_exec_host_out
        local cmd_stat=$?
        _update_check_stat $cmd_stat $tmpfile_exec 
        #echo $tmpfile_exec_out 
        #[[ -f $tmpfile_exec_out ]] || echo ${FUNCNAME[@]} $tmpfile_exec_out is missing 
        if [[ $cmd_stat -eq 0 ]] && [[ $(wc -l <$tmpfile_exec_out) -eq 0 ]] ;then 
            cat $tmpfile_exec_host_out > $tmpfile_exec_out 
            #_ssh_send " echo -e \" HOST:\e[34m\$HOSTNAME \e[0m \" "
            _segline "group: \"$current_host_group\" command std output"
            cat $tmpfile_exec_host_out
            _segline "group: \"$current_host_group\" command output end"
            echo ""
        elif [[ -n $(diff $tmpfile_exec_out $tmpfile_exec_host_out) ]] ;then
            _ssh_send " echo -e \" HOST:\e[34m\$HOSTNAME \e[0m \" "
            _segline "$host_ip  stdout"
            cat $tmpfile_exec_host_out
            _segline "$host_ip cmd end"
            echo ""
        else
            _blue "  $host_ip same output as common" # "group: \"$current_host_group\" \n"
        fi
        rm -rf $tmpfile_exec_host_out 
    else 
        # do not merge output 
        _ssh_send " echo -e \" HOST:\e[34m\$HOSTNAME \e[0m \" "
        _segline "$host_ip  stdout"
        ssh -t -q -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o PubkeyAuthentication=yes -o PasswordAuthentication=no -l $host_user $host_ip -p $host_port "$CMD"
        local cmd_stat=$?
        _update_check_stat $cmd_stat $tmpfile_exec 
        _segline "$host_ip cmd end"
    fi
#else
#    _unquiet "    no command to run."
fi
}
##############################################################################################
function _ssh_send_bknd(){
    if [[ $# -lt 1 ]] ;then
        echo "${FUNCNAME[@]} warning: no command to send!" 
        continue
    else
        #ssh -t -q -n -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o PubkeyAuthentication=yes -o PasswordAuthentication=no -l $bknd_user $bknd_ip -p $bknd_port "$@" 
        ssh -T -q -n -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o PubkeyAuthentication=yes -o PasswordAuthentication=no -l $bknd_user $bknd_ip -p $bknd_port "$@" 
    fi 
}
function _ssh_bknd(){
# input :
#        $1 with 3 field : user,port,ip_of_backen_server(sep with comma)
#        $2 is the source file and target dir 
#        $3 is the command.
#        $4 is the output file name.
    # format completion
    if [[ -n $1 ]]
    then
        [[ -z $2 ]] && echo "lost scripts info to send to backend server" && exit 1
        [[ -z $3 ]] && echo "lost command info to send to backend server" && exit 1
        [[ -z $4 ]] && echo "lost output log filename for backend server" && exit 1
        if [[ $1 != "none" ]]
        then
            if [[ $(echo $1 |grep -o '\,'|wc -l) -eq 2 ]]
            # 3 field, separated with 2 comma
            then
                # full format.
                bknd_ip=${1##*,}
                bknd_user=${1%%,*}
                bknd_port=$(echo $1 |cut -d, -f2)
            elif [[ ! $1 =~ "," ]]
            # defautl user root, port 22
            then 
                # format completion for default field.
                bknd_ip=${1}
                bknd_user="root"
                bknd_port=22
            else
            # another barbarism format!!
                echo "host group backend info, format error, $1"
            fi
#           shift
            _unquiet "    send cmd/file to backend $bknd_ip ..."
            # network and ssh connection test.
            if ping -c2 $bknd_ip  &>/dev/null ;then
                if _ssh_send_bknd "echo ssh ok" &>/dev/null ;then
                    # copy file and run command after net and ssh test.
                    file_stat=$(_ssh_send_bknd "test -f ${2#*[ ]}/${2%[ ]*}; echo $?")
                    [[ $file_stat -eq 0 ]] || scp -P $bknd_port ${2%[ ]*} $bknd_user@$bknd_ip:${2#*[ ]} 
                    #
                    _ssh_send_bknd "${3}" &>"$4" &
                    _unquiet "    task pid $! in background..." || echo "    task pid:$!"
                else
                    _red "bknd server $bknd_ip ssh connection failed!"
                fi
            else
                _red "bknd server $bknd_ip is unreachable!"
                #_error_interrupt
            fi
            _verbose bknddetail && _blue "\
file: ${2%[ ]*}
dir : ${2#*[ ]}
cmd : $3
log : $4
" \
&& _waiting "reading" 5
        fi
    else
        echo "no host group backend server info recived!"
    fi
}
####################################################
# change for a different backend change this part
####################################################
function _record_backend(){
# collect backend tcmu and ceph
# works when tcmu_bknd/ceph_bknd was set
# no input.
    if [[ -n ${JOB_RUNTIME_ARRAY[$job_group_name]} ]] 
    then 
        tcmu_runtime="$(expr ${JOB_RUNTIME_ARRAY[$job_group_name]} - 50 )"
        ceph_runtime="${JOB_RUNTIME_ARRAY[$job_group_name]}"
    else
        echo "job group $job_group_name, job runtime recived err, value empty!"
        exit 1
    fi
    tcmu_load_logfile=$job_name-tcmu_load.log
    tcmu_iops_logfile=$job_name-tcmu_iops.log
    ceph_iobw_logfile=$job_name-ceph_iobw.log
    if [[ $tcmu_bknd != "none" ]] ;then
        _ssh_bknd "$tcmu_bknd" "bin/cal_cpu_mem.sh /root/"         "bash /root/cal_cpu_mem.sh $tcmu_runtime"         "$log_dir/$tcmu_load_logfile"
        _ssh_bknd "$tcmu_bknd" "bin/cal_tcmu_total_iops.sh /root/" "bash /root/cal_tcmu_total_iops.sh $tcmu_runtime" "$log_dir/$tcmu_iops_logfile"
    else 
        echo "    bknd partially skiped"
    fi
    if [[ $ceph_bknd != "none" ]] ;then
        _ssh_bknd "$ceph_bknd" "bin/cal_ceph_bw_iops.sh /root/"    "bash /root/cal_ceph_bw_iops.sh $ceph_runtime"    "$log_dir/$ceph_iobw_logfile"
    else 
        echo "    bknd partially skiped"
    fi
    _verbose "bkndinfo" && _waiting "reading" 5
}
##############################################################################################
function _host_fio_check(){
    if ping -c1 $host_ip &>/dev/null ;then
        # wait five secends, let fio start its jobs
        sleep 5
    else
        _pingfail 
        #_error_interrupt
    fi
    while _ssh_send 'ps aux |grep fio |grep filename |grep -qv grep ' ;do
        _verbose  hostinfo && _waiting "reading" 5
        sleep 5
    done
    while _ssh_send 'ps aux |grep fio |grep rbdname |grep -qv grep ' ;do
        _verbose  hostinfo && _waiting "reading" 5
        sleep 5
    done
}
function _send_fio(){
# send fio job and collect backend server info.
# no input
# works when:
#       blk_group_name was set
#       job batch info was set
#       host ssh info was set
#       bknd ssh info was set
#       and so on ...
    if [[ $send_fio == "True" ]] ;then
        if [[ ! -d $output_dir ]] ;then
            mkdir -p $output_dir
        fi
        # check if multy blkgroup/jobgroup
        [[ $multy_blk_group == "True" ]] && local path_flyover=$blk_group_name
        [[ $multy_job_group == "True" ]] && local path_flyover+=/$job_group_name 
        #log_dir
        if [[ -n path_flyover ]];then
            #
            log_dir="$output_dir/$path_flyover/$blk_group_name-$job_group_name-$current_host_group-$host_ip"
        else 
            #
            log_dir="$output_dir/$blk_group_name-$job_group_name-$current_host_group-$host_ip"
        fi
        # mkdir 
        [[ -d $log_dir ]] ||  mkdir -p $log_dir
        # record info for analysing
        [[ -f $log_dir/fio-batch'.log' ]] || echo -e "bs:\npattern:\nblk:\n" >$log_dir/fio-batch".log"
#sleep 20
        if _ssh_send "fio -v" &>/dev/null ;then
            # log on remote host
            _ssh_send "mkdir -p $log_dir"
            if [[ $rbd_mode == "True" ]] ;then 
                local host_blk_list=${HOST_GROUP_RBD_DEV_ARRAY[$host_ip]}
            else 
                local host_blk_list=${BLK_DEV_ARRAY[$blk_group_name]}
            fi 
#    pdebug=True 
#    _rbd_expansion 
#_marker "dev info"
#    echo ${HOST_GROUP_RBD_DEV_ARRAY[*]}
#    echo ${!HOST_GROUP_RBD_DEV_ARRAY[*]}
#    pdebug=False 
# sleep 30 
            for BLK in $host_blk_list 
            do
                # check blk file
                if _ssh_send "ls $BLK" &>/dev/null ;then
                    log_name=$job_name-${BLK//\//}".log.json"
                    # check sata disk with smartctl, nvme disks are not supported
                    local blk_name=${BLK##*/}
                    if [[ $rbd_mode == "True" ]] ;then
                        # skip rbd check   
                        :
                    elif [[ ${blk_name//nvme/} != "${blk_name}" ]] ;then
                        # skip nvme
                        :
                    elif [[ $(_ssh_send "smartctl -V &>/dev/null ;echo \$?") -eq 0 ]] ;then
                        # if smartmontools installed, check status.
                        blk_stats=$(_ssh_send "smartctl -H $BLK |grep 'SMART Health Status:' |awk '{print\$NF}' ")
                        [[ $blk_stats != "OK" ]] && _verbose &&"info: $host_ip \"$BLK\" smartmontools check failed."
                    fi
                elif [[ $rbd_mode == "True" ]] ;then
                    #
                    log_name=$job_name-${BLK//\//}".log.json"
                    _verbose && echo "log name: $log_name"
                else
                    #_red "host: $host_ip, blk or file : \"$BLK\" is not available on host!"
                    _devfail 
                    _verbose "jobinfo"
                fi
                # ready to send
                _verbose "jobinfo" && _waiting "reading" 15
                if [[ $test_mode == "single" ]] ;then
                    #_ssh_send "$fio_cmd -filename=$BLK -name=$log_name " &>$log_dir/$log_name
                    # wait previous 
                    _host_fio_check
                    if [[ $rbd_mode == "True" ]];then 
                        _ssh_send "$fio_cmd -rbdname=$BLK -name=$num_jobs-$log_name  &>$log_dir/$log_name &"
                        echo $job_batch_index $(date +%Y%m%d_%H:%M:%S) "$fio_cmd -rbdname=$BLK -name=$num_jobs-$log_name   &>$log_dir/$log_name" >>$log_dir/fio-batch".log"
                    else 
                        _ssh_send "$fio_cmd -filename=$BLK -name=$num_jobs-$log_name  &>$log_dir/$log_name &"
                        echo $job_batch_index $(date +%Y%m%d_%H:%M:%S) "$fio_cmd -filename=$BLK -name=$num_jobs-$log_name  &>$log_dir/$log_name" >>$log_dir/fio-batch".log"
                    fi
                else
                    if [[ $rbd_mode == "True" ]];then
                        _ssh_send "$fio_cmd -rbdname=$BLK -name=$num_jobs-$log_name  &>$log_dir/$log_name &"
                        echo $job_batch_index $(date +%Y%m%d_%H:%M:%S) "$fio_cmd -rbdname=$BLK -name=$num_jobs-$log_name   &>$log_dir/$log_name" >>$log_dir/fio-batch".log"
                    else
                        _ssh_send "$fio_cmd -filename=$BLK -name=$num_jobs-$log_name  &>$log_dir/$log_name &"
                        echo $job_batch_index $(date +%Y%m%d_%H:%M:%S) "$fio_cmd -filename=$BLK -name=$num_jobs-$log_name  &>$log_dir/$log_name" >>$log_dir/fio-batch".log"
                    fi
                fi
                #record job bs, pattern, blk
                #bs info
                grep  "^bs:.*$" $log_dir/fio-batch".log" \
                |grep -q ",${job_name%-*}" \
                || sed -i "s/^bs:.*$/&\,${job_name%-*}/g" $log_dir/fio-batch".log"
                #pattern info
                grep  "^pattern:.*$" $log_dir/fio-batch".log" \
                |grep -q ",${job_name#*-}" \
                || sed -i "s/^pattern:.*$/&\,${job_name#*-}/g" $log_dir/fio-batch".log"
                #blk info
                grep "^blk:.*$" $log_dir/fio-batch".log" \
                |grep -q ",${BLK//\//}"  \
                || sed -i "s/^blk:.*$/&\,${BLK//\//}/g" $log_dir/fio-batch".log"
            #
            done
            if [[ $tcmu_bknd != "none" ]] || [[ $ceph_bknd != "none" ]] ;then
                _unquiet "  connect bknd server ..."
                _record_backend
            fi
        else
            _update_check_stat 1 $tmpfile_exec
            _red "   $host_ip, fio is not ready !"
        fi 
    fi
}  
##############################################################################################
# job task delivery
##############################################################################################
# host
function _exec_with_job(){
# file , cmd , fio
    _send_file
    # action after send files
    _verbose && _blue "execut emode:$execute_mode"
    if [[ $execute_mode == "After" ]] ;then
        _unquiet "command running first."
        #command first
        _send_cmd && wait && _send_fio
    else
        _send_fio && wait && _send_cmd
    fi
}
# host
function _exec_only_oth(){
# file , cmd 
# exec in parallel too
    if [[ $p_exec == "True" ]] ;then
        _send_file && _send_cmd && _harvest_file & 
    else
    #send cmd sequentially
        _send_file
        _send_cmd
        _harvest_file
    fi
}
# host
function _exec_all(){
    if ping -c2 $host_ip &>/dev/null ;then
        #
        if _ssh_send " echo \$(whoami) " &>/dev/null ;then
        # file , cmd , fio
            if [[ $send_fio == "True" ]] ;then
                # put fio in bg, no need to wait and skip to next host immediately.
                _exec_with_job &
            else
            # file , cmd 
                _exec_only_oth
            fi
        else
            _sshfail 
            _update_check_stat 1 $tmpfile_exec
        fi && wait
        #_unquiet "  host:$host_ip distribution done "
    else
        _pingfail 
        #_error_interrupt
        _update_check_stat 1 $tmpfile_exec
    fi
}
function _group_execute(){
# files/command/jobs was set
# blk_group_name was set (when lunch a test on cluster.)
# host_group_name was set
    _yellow "execute:"
    _parse_host_info "$1"
        tmpfile_exec=$(mktemp)
        [[ -z $tmpfile_exec_out ]] && tmpfile_exec_out=$(mktemp)
        # rm tmpfile_exec_out till fio test end, but clean content each round of test 
        [[ $send_fio == "True" ]] && echo -n "" >$tmpfile_exec_out 
        #echo  mkfile $tmpfile_exec_out 
        echo 0 > $tmpfile_exec
        for host_ip in $ip_list ;do
             #ping check
             if [[ $p_exec == "True" ]] || [[ $send_fio == "True" ]] ;then
                 _exec_all &
             else
                 _exec_all 
             fi
        done && wait 
        # read stat after all exec done
        check_stat=$(sort -nr $tmpfile_exec |head -1)
        rm -rf $tmpfile_exec
        #echo rm file  $tmpfile_exec_out
        # rm tmpfile_exec_out after one round execution
        #[[ $send_fio != "True" ]] && rm -rf $tmpfile_exec_out # remove it in the end of script .
        #if some failed, read done, show status
        [[ $check_stat -eq 1 ]] && echo "$1 group execution partially failed." && _error_interrupt
    _unquiet "$1: execute action done." || echo " group stat : $check_stat"
}
function _host_fio_list(){
    if ping -c1 $host_ip &>/dev/null ;then 
        if _ssh_send 'echo ok' &>/dev/null ;then
            tmpfile=$(mktemp)
            tmpfile2=$(mktemp)
            host_stat=0
            host_name=$(_ssh_send 'echo $HOSTNAME')
            [[ ${#host_name} -gt 18 ]] && host_name="${host_name:0:18}.."
            # get args info
            local blk_keywd="filename"
            if _ssh_send "ps aux |grep fio |grep rbdname  |grep -vq grep" ;then
                local blk_keywd="rbdname"
            fi
            _ssh_send "ps aux|grep fio|grep $blk_keywd |grep -v grep" > $tmpfile
            # get time info
            _ssh_send "ps -aeo user,pid,etimes,args|grep fio|grep $blk_keywd|grep -v grep |awk '{for(i=3;i<4;i=i+1){printf \$i\" \"};printf \"\n\"}'|sort -u"  > $tmpfile2
            no_job=$(wc -l < $tmpfile) 
            job_pattern=$(awk -F "rw=" '{print$2}' $tmpfile |awk '{print$1}'|sort -u |sed ':label;N;s/\n/\ /;t label')
            job_bs=$(awk -F " -bs=" '{print$2}' $tmpfile |awk '{print$1}'|sort -u |sed ':label;N;s/\n/\ /;t label')
            max_runtime=$(awk -F "runtime=" "{print\$2}" $tmpfile|awk "{print\$1}"|sort -u |head -1)
            disk_list=$(awk -F"$blk_keywd=" '{print$2}' $tmpfile|awk '{print$1}'|sed 's/\/dev\///g' |sort -u |sed ':label;N;s/\n/\ /;t label')
            no_disk=$(awk -F"$blk_keywd=" '{print$2}' $tmpfile|awk '{print$1}' |sort -u |wc -l)
            # nojobs running
            [[ -z $job_pattern ]] && job_pattern="none"
            # mixed read and write, no bs
            if [[ -z ${job_bs// /} ]] ;then
               job_bs=$(awk -F " -bssplit=" '{print$2}' $tmpfile |awk '{print$1}'|sort -u |sed ':label;N;s/\n/\ /;t label') 
               if [[ -n ${job_bs// /} ]] ;then
                   job_bs="mixed"
               else
                   job_bs="none"
               fi
            fi
            if [[ -z "$max_runtime" ]] ;then
                max_runtime="0"
                time_left="0"
            else
                # latest start time
                time_gone=$(sort -n $tmpfile2 |grep -v [a-z,A-Z] |head -1 )
                time_left=$(echo $max_runtime $time_gone |awk '{print$1 - $2}')
                # change format to readable.
                time_left=$(_unit_time "$time_left")
                max_runtime=$(_unit_time "$max_runtime")
            fi
            [[ -z "$disk_list" ]] && disk_list="none"
          #output
      else
            host_stat=1
            host_name='ssh inaccessible :('
      fi 
    else
            host_stat=1
            host_name='ip unreachable :('
    fi
        # check done
        if [[ $host_stat -eq 1 ]] ;then
            check_stat=1
            no_job='-' ;max_runtime='-' ;time_left='-' ;job_bs='-' ;job_pattern='-';no_disk='-' ;disk_list='-'
            printf "\e[1;31m%-21s%-16s%-6s%-12s%-12s%-8s%-11s%-9s%-30s\n\e[0m" "$host_name" "$host_ip" "$no_job" "$max_runtime" "$time_left" "$job_bs" "$job_pattern" "$no_disk" "$disk_list"
        else
            printf "%-21s%-16s%-6s%-12s%-12s%-8s%-11s%-9s%-30s\n" "$host_name" "$host_ip" "$no_job" "$max_runtime" "$time_left" "$job_bs" "$job_pattern" "$no_disk" "$disk_list"
        fi
        rm -rf $tmpfile $tmpfile2 
}
function _group_fio_list(){
# list job on a host group
    _yellow "job list:"
    _parse_host_info "$1"
    # |host name | host ip | No. of jobs | max runtime | disk/file in use | bs | rw pattern | disk/file list |
    printf "%-21s%-16s%-6s%-12s%-12s%-8s%-11s%-9s%-30s\n" "host-name" "host-ip" "jobs" "max-runtime" "max-remain" "bs-size" "rw-pattern" "blk/file" "blk/file-list"
    # get and print job info .
    #    check_stat=0
    for host_ip in $ip_list ;do
        if [[ $p_exec == "True" ]];then
            _host_fio_list &
        else
            _host_fio_list
        fi
    done && wait
#    [[ $check_stat -eq 1 ]] && _error_interrupt
#    _unquiet "list action done." || echo -e "\tstat: $check_stat"
}
##############################################################################################
function _group_fio_log_harvest(){
# blk_group_name was set (when lunch a test on cluster.)
# host_group_name was set
    _yellow "harvest log:"
# check outputdir name 
if [[ -n $output_dir  ]] ;then
    _parse_host_info "$1"
        tmpfile_hvst=$(mktemp)
        echo 0 > $tmpfile_hvst
        for host_ip in $ip_list ;do
            #ping check
            if ping -c2 $host_ip &>/dev/null ;then
                if _ssh_send " echo \$(whoami) " &>/dev/null ;then
#echo "output_dir $output_dir"
#sleep 30
                    # stop scp from coping "/" from remote, when output dir missing
                    if [[ -n $output_dir ]] && [[ $output_dir != '/' ]] ;then
                        scp -q -r -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o PubkeyAuthentication=yes -o PasswordAuthentication=no -P $host_port $host_user@$host_ip:$output_dir/* $output_dir/ 
                        _update_check_stat $? $tmpfile_hvst 
                        # wait
                        _ssh_send "rm -rf $output_dir/"
                        _update_check_stat $? $tmpfile_hvst 
                    else
                        _red "output directory err!" && _verbose "jobinfo"
                        _update_check_stat 1 $tmpfile_hvst 
                    fi
                else
                    _sshfail 
                    _update_check_stat 1 $tmpfile_hvst 
                fi
            else
                _pingfail 
                #_error_interrupt
                _update_check_stat 1 $tmpfile_hvst
            fi &
        done && wait
    check_stat=$(sort -nr $tmpfile_hvst |head -1)
    rm -rf $tmpfile_hvst
#    if [[ -f $tmpfile_exec ]] && [[ $check_stat == 1 ]] ;then
#        _update_check_stat 1 $tmpfile_exec
#    fi
    [[ $check_stat -ne 0 ]] && echo "$1 log harvest partially failed." && _error_interrupt
    _unquiet "$1: log harvest done." || echo " group stat : $check_stat"
else
    _red "empty output dir" && _verbose "jobinfo"
fi
}
#function _fio_scale_watch(){}

function _group_fio_stop(){
# stop all existing fio jobs on host group
    _yellow "fio stop:"
    _parse_host_info "$1"
        tmpfile_stop=$(mktemp)
        echo 0 >$tmpfile_stop
        for host_ip in $ip_list ;do
            if ping -c2 $host_ip &>/dev/null ;then
                if _ssh_send 'echo ssh ok' &>/dev/null ;then
                    if _ssh_send 'ps aux |grep fio|grep filename |grep -v grep' &>/dev/null ;then
                        _ssh_send 'kill $(ps aux |grep fio|grep filename |grep -v grep|awk "{print\$2}") ' \
                        && _unquiet " $(_blue "host: $host_ip") fio process killed successfully."
                    else
                        _unquiet " $(_blue "host: $host_ip") no fio running"
                    fi
                else
                    _sshfail 
                fi
            else
                _pingfail 
                #_error_interrupt
                echo 1 >$tmpfile_stop
            fi &
# if run in backgroud return will always be 0
        done && wait
        check_stat=$(cat $tmpfile_stop)
        [[ $check_stat -eq 1 ]] && _error_interrupt
    _unquiet "$1: round stop action done." || echo "stop stat: $check_stat" 
}

# stop test on a group
function _group_test_stop(){
    _yellow "test stop:"
    _parse_host_info "$1"
# stop all background test process on local host
    echo "  stop main test process..."
    local main_pid=$(ps aux |grep '\-\-'fio'\ ' |grep "$1" |grep -v grep |awk '{print$2}')
    [[ -n $main_pid ]] && kill $main_pid || echo "  main process was ended already."
#stop fio jobs
        echo "  stop fio jobs on hosts..."
        tmpfile_stop=$(mktemp)
        #echo 0 >$tmpfile_stop
        _update_check_stat 0 $tmpfile_stop
        for host_ip in $ip_list ;do
            # stop local process
            local host_pid=$(ps aux |grep $(whoami) |grep $host_ip |grep ssh |grep -v grep |awk '{print$2}')
            [[ -n $host_pid ]] && kill $host_pid 
            # stop fio on host
            if ping -c2 $host_ip &>/dev/null ;then
                if _ssh_send 'echo ssh ok' &>/dev/null ;then
                    if _ssh_send 'ps aux |grep fio|grep filename |grep -v grep' &>/dev/null ;then
                        _ssh_send 'kill $(ps aux |grep fio|grep filename |grep -v grep|awk "{print\$2}") ' \
                        && _unquiet " $(_blue "host: $host_ip") fio process killed successfully."
                    else
                        _unquiet " $(_blue "host: $host_ip") no fio running"
                    fi
                else
                    _sshfail 
                    _update_check_stat 1 $tmpfile_stop
                fi
            else
                _pingfail 
                #_error_interrupt
                #echo 1 >$tmpfile_stop
                _update_check_stat 1 $tmpfile_stop
            fi &
# if run in backgroud return will always be 0
        done && wait
        #check_stat=$(cat $tmpfile_stop)
        check_stat=$(sort -nr $tmpfile_stop |head -1)
        [[ $check_stat -ne 0 ]] && _error_interrupt
    _unquiet "$1: stop action done." || echo "stop stat: $check_stat" 
}

function _group_fio_check(){
# check and wait when fio jobs detected on a given host group
    _yellow "running stat check:"
    _parse_host_info "$1"
        #check_stat=0
       echo " check and wait running fio jobs."
        for host_ip in $ip_list ;do
            _verbose hostinfo && _waiting "reading" 5
            if ping -c1 $host_ip &>/dev/null ;then
                :
            else
                _pingfail 
                continue 
                #_error_interrupt
            fi
# no fio between 15 secends check, three times of send interval
            if _ssh_send 'ps aux |grep fio |grep filename |grep -qv grep ' ;then
                while _ssh_send 'ps aux |grep fio |grep filename |grep -qv grep ' ;do
                    sleep 30
                done
            # rbd test check
            elif _ssh_send 'ps aux |grep fio |grep rbdname |grep -qv grep ' ;then
                while _ssh_send 'ps aux |grep fio |grep rbdname |grep -qv grep ' ;do
                    sleep 30
                done
            else
                sleep 15
                while _ssh_send 'ps aux |grep fio |grep filename |grep -qv grep ' ;do
                    sleep 30
                done
                # wait rbd
                while _ssh_send 'ps aux |grep fio |grep rbdname |grep -qv grep ' ;do
                    sleep 30
                done
            fi &
        done && wait
    #[[ $check_stat -eq 1 ]] && _error_interrupt
    _unquiet "$1: check action done."  # || echo " group stat : $check_stat" 
}
function _group_pre_check(){
# check and wait when fio jobs detected on a given host group
    _yellow "host pre check:"
    _parse_host_info "$1"
#        check_stat=0
        tmpfile_precheck=$(mktemp)
        # echo 0 > $tmpfile_precheck
        for host_ip in $ip_list ;do
            _verbose "hostinfo" && _waiting "reading" 5
            # network check
            if ping -c 2 $host_ip &>/dev/null ;then
                if ! _ssh_send 'whoami' &>/dev/null ;then
                    _sshfail 
                    continue 
                fi
                #check fio installation
                if _ssh_send 'fio -v' &>/dev/null ;then
                    _update_check_stat 0  $tmpfile_precheck
                    version=$(_ssh_send "rpm -q fio |awk -F[-.] '{print\$2}'")
                    if [[ -z $version ]] ;then
                        _verbose && _blue "host:$host_ip fio was not installed through rpm/yum."
                        version=$(_ssh_send "fio -v |awk -F[-.] '{print\$2}'")
                    fi
                    if [[ $version -ge 3 ]]  ;then
                        _unquiet "  host:$host_ip fio check ok"
                    else
                        _unquiet "$(_yellow "warning"): host:$host_ip fio version: $version, version 3+ will be better."
                    fi
                # no fio installed
                else
                    # check version makecache fast 
                    if _ssh_send 'yum makecache fast >/dev/null' ;then
                        version=$(_ssh_send "yum list fio|grep fio|tail -1|awk '{print \$2}'|cut -d'.' -f1")
                       if [[ $version -ge 3 ]] ;then 
                           _update_check_stat 2  $tmpfile_precheck
                           _blue "host:$host_ip, fio installing.."
                           # fio installing in background 
                           # install fio , makecache 
                           if _ssh_send 'fio -v 2>/dev/null || yum makecache >/dev/null' ;then 
                               _ssh_send 'fio -v 2>/dev/null || yum -y install librbd1 fio &>/dev/null &'
                               # get smartmontools installed
                               _verbose && _ssh_send 'smartctl -V &>/dev/null || yum -y install smartmontools &>/dev/null' & 
                           else
                               _red "host:$host_ip: fio installation, makecache failed"
                               _update_check_stat 1 $tmpfile_precheck
                           fi
                       else 
                           echo "host:$host_ip, fio check failed. (not installed and fio version: $version in available repo is lower than 3)"
                           _update_check_stat 1 $tmpfile_precheck
                       fi
                    else
                        _red "host:$host_ip: fio installation, makecache failed"
                        _update_check_stat 1 $tmpfile_precheck
                    fi
                fi
                # try get rsync installed if possible
                #_ssh_send 'rsync --version || yum -y install rsync' &>/dev/null &
            else
                _pingfail 
                #_error_interrupt
                _update_check_stat 1 $tmpfile_precheck
            fi &
        done && wait
        # abckend process parameters lost  
        check_stat=$(sort -nr $tmpfile_precheck |head -1)
        if grep -q 2 $tmpfile_precheck ;then 
            # if recheck , count number abort at 5
            if [[ -n $recheck ]] ;then 
                # stop recheck after 5 round recheck
                if [[ $recheck -eq 5 ]] ;then 
                    if grep -q 0 $tmpfile_precheck ;then 
                        _red "host group \"$1\" fio installation failed after $recheck round recheck!!"
                        # skip this group 
                        _error_interrupt && continue 
                        return 1
                    else
                        _red "ERROR: NO success signal of fio installation recived on \"$1\" ! it is not possible to continue on this group !!"
                        _red "$date abort!"
                        exit 1
                    fi
                else
                    recheck=$[recheck +1] 
                    _yellow "host group $1, fio installation recheck Round_No: $recheck "
                fi
            else
                # first round 
                local recheck=1
                _yellow "check status abnormal, start fio installation recheck ..."
            fi
            # clean tmpfile and recheck 
            rm -rf $tmpfile_precheck
            _yellow "waiting fio installation (yum) ... "
            sleep 20
            _group_pre_check "$1"
        #elif grep -q 1 $tmpfile_precheck ;then
        #    echo check stat : $check_stat 
        fi
        [[ -f $tmpfile_precheck ]] && rm -rf $tmpfile_precheck &>/dev/null 
        # if fio failed, no need to continue
        [[ $check_stat -eq 1 ]] && echo "$1 pre check partially failed." && _timeout 15 && _error_interrupt
    _unquiet "host group $1: pre check action done. group stat : $check_stat " || echo " group $1 stat : $check_stat" 
}
function _group_blk_detect(){
# detected possible target blk on a given host group
    _yellow "group blk detecting:"
    _parse_host_info "$1"
        tmpfile_grp_blk_detected=$(mktemp)
        for host_ip in $ip_list ;do
            _verbose "hostinfo" && _waiting "reading" 5
            # network check
            if ping -c 1 $host_ip &>/dev/null ;then
                # ssh check 
                if _ssh_send 'whoami' &>/dev/null ;then
                    tmpfile_host_blk_detected=$(mktemp)
                    # get all blk info form ssh 
                    _ssh_send "lsblk -ps" >$tmpfile_host_blk_detected
                    #check blk device     ## do not quote the slash '', it's not ascii format ! 
                    #local host_blk_detected=$(grep disk $tmpfile_host_blk_detected |grep -v  |awk '{print$1}')
                    local host_blk_detected=$(grep disk $tmpfile_host_blk_detected |grep ^'/' |awk '{print$1}')
                    # get root disk info from root partition
                    local host_root_info=($(grep /$ $tmpfile_host_blk_detected))
                    echo ${host_root_info[@]} |grep -q disk || local host_root_info=($(grep /$ -A1 $tmpfile_host_blk_detected|tail -1))
                    echo ${host_root_info[@]} |grep -q disk || local host_root_info=($(grep /$ -A2 $tmpfile_host_blk_detected|tail -1))
                    #[[ ${host_root_info[-2]} != "disk" ]] && local host_root_info=($(grep /$ -A1 $tmpfile_host_blk_detected|tail -1))
                    #[[ ${host_root_info[-2]} != "disk" ]] && local host_root_info=($(grep /$ -A2 $tmpfile_host_blk_detected|tail -1))
                #echo root info: ${host_root_info[@]}
                    local host_root_disk=${host_root_info[0]//[^a-z,'/']/}
                #echo root name: $host_root_disk
                    # get size info of root disk 
                    local host_root_size=$(grep $host_root_disk'\ ' $tmpfile_host_blk_detected |sort -u |awk '{if(NR==1)print$4}' )
                #echo root size: $host_root_size
                    # check all detected disks on host 
                    for i in $host_blk_detected ;do
                        # add new disk when it's not in detected blk dev list.
                        if ! grep -q $i $tmpfile_grp_blk_detected ;then 
                            # check it's size.
                            local tmp_blk_size=$(grep ^$i'\ ' $tmpfile_host_blk_detected |sort -u |awk '{if(NR==1)print$4}')
                            [[ $tmp_blk_size == $host_root_size ]] && local disk_note=" # same size as disk of root partition"
                            # [[ $? -eq 0 ]] && echo $i size $tmp_blk_size
                            echo $i"," "$disk_note" >> $tmpfile_grp_blk_detected  && disk_note=''
                            # check if other data disk same size as root 
                            local RootSize_nu=$(grep ^/ $tmpfile_host_blk_detected |grep $host_root_size|grep disk |wc -l)
                            local AllDisk_nu=$(grep ^/ $tmpfile_host_blk_detected |grep disk |wc -l)
                            #only one blk same size as root, and others not  
                            if [[ $RootSize_nu -eq 2 ]] && [[ $AllDisk_nu -ge $RootSize_nu ]] ;then 
                                sed -i "/^${i//\//\\/}/s/^/#/" $grp_blk_conf
                            fi 
                        fi
                    done
                    rm -f $tmpfile_host_blk_detected
                else 
                    _sshfail 
                fi
            else
                _pingfail 
                #_error_interrupt
            fi &
        done && wait 
        #output blk list to group blk configfile 
        echo check done 
        sleep 5
        if [[ ! -f $(dirname $0)/conf/$1".blk" ]] ;then 
            sort -u $tmpfile_grp_blk_detected > $(dirname $0)/conf/$1".blk" 
            sed -i "$ s/\,//g" $(dirname $0)/conf/$1".blk"
            # show detected blk list 
            _yellow "new blk config file: $(dirname $0)/conf/$1.blk"
            cat $(dirname $0)/conf/$1".blk"
        elif ! _format_conf $b_conf |grep -q ^$1 ;then 
            #sed -i "$ s/\,//g" $tmpfile_grp_blk_detected 
            # show detected blk list 
            _yellow "\ncurrently nonpartitioned blk list of group $1:"
            uniq -c $tmpfile_grp_blk_detected
            echo ""
        fi
        # clean tmpfile 
        rm -f $tmpfile_grp_blk_detected
}
function _group_blk_precheck(){
    #check if detected blk available on every host 
    _yellow "group blk recheck:"
    _parse_host_info "$1"
local grp_blk_conf=$(dirname $0)/conf/$1".blk"
if [[ -f $grp_blk_conf ]] ;then 
    local blk_list=$(_format_conf $grp_blk_conf)
    if [[ -n $blk_list ]] ;then 
        local blk_list=${blk_list//,/ }
        for host_ip in $ip_list;do
            if ping -c 1 $host_ip &>/dev/null ;then
                if _ssh_send 'whoami' &>/dev/null ;then
                    #
                    for blk in $blk_list ;do 
                        _ssh_send "lsblk -p $blk" &>/dev/null 
                        if [[ $? -ne 0 ]] ;then
                            _devfail 
                            [[ -z $blk_fail_note ]] && local blk_fail_note='# not valid on host:' || blk_fail_note=','
                            grep -q $host_ip || sed -i "/^${blk//\//\\/}/s/$/ $blk_fail_note$host_ip/" $grp_blk_conf
                            #sed -i "/^${blk//\//\\/}/s/^/#/" $grp_blk_conf
                        elif [[ $(_ssh_send "lsblk -p $blk |wc -l") -ne 2 ]] ;then
                            _devfail 
                            [[ -z $blk_fail_note ]] && local blk_fail_note='# not valid on host:' || blk_fail_note=','
                            grep -q $host_ip || sed -i "/^${blk//\//\\/}/s/$/ $blk_fail_note$host_ip/" $grp_blk_conf
                            #sed -i "/^${blk//\//\\/}/s/^/#/" $grp_blk_conf
                        fi 
                        unset blk 
                    done
                else
                    _sshfail 
                fi
            else
                _pingfail 
            fi &
        done && wait 
        # show blk list after recheck 
        _yellow "currently valid blk list of $1:"
        grep -v "^#" $grp_blk_conf || _red "  $grp_blk_conf :No valid block device for group: $1 !" 
    else
        _red "  $grp_blk_conf contains no valid block devices."
    fi
else 
    echo "$grp_blk_conf not exist, skiped"
fi 
    echo "$1: blk recheck done"
}
function round_report(){
    if [[ -n $job_batch_index ]]; then
        # analise json log
        local   previous_job_group_name="${JOB_BATCH_NAME_ARRAY[$job_batch_index]%%-*}"
        local previous_job_pattern_name="${JOB_BATCH_NAME_ARRAY[$job_batch_index]#*-}"
        # check if multy blkgroup/jobgroup
        local path_flyover=$output_dir 
        [[ $multy_blk_group == "True" ]] && local path_flyover+=/$blk_group_name
        [[ $multy_job_group == "True" ]] && local path_flyover+=/$previous_job_group_name
        # loop through all host, get json file list of last round 
        for host_log_dir  in $(ls $path_flyover/* -d );do 
            # if retest, skip report folder 
            [[ ${host_log_dir##*/} == "_report" ]] && continue 
            for json_file in $(find $host_log_dir -type f -name "$previous_job_pattern_name"*.log.json );do 
                # check format 
                python2 $(dirname $0)/bin/cfiojobs.json.py $json_file &>/dev/null || _red "$json_file : log stat abnormal!"
            done 
        done 
    fi
}
function _list_all_running_jobs(){
    local groups_to_list=$(ps aux |grep $(whoami) |grep -E "\-\-fio|\-\-fio\ " |grep -v grep |awk -F'-g' '{print$2}' |awk '{print$1}' |sort -u)
    if [[ -n $groups_to_list ]] ;then
        for i in $groups_to_list ;do
            bash $0 -g $i --fio-list -p 
        done
    else
        echo "no groups to list"
    fi
}

function _check_output_dir(){
        #check output directory, set default to a datatime stamp.
        if [[ -z $output_dir ]] ;then
            [[ $send_fio == "True" ]] && output_dir="${0#*/}-test-$date" || output_dir="${0#*/}-file-$date"
            _yellow "INFO: no output dir name specified, \"$output_dir\" will be the default name."
        elif [[ -d $output_dir ]] || mkdir -p $output_dir ;then
            :
        else
            [[ $send_fio == "True" ]] && output_dir="${0#*/}-test-$date" || output_dir="${0#*/}-file-$date"
            _red "Warn: the output dir creation failed !" 
            _yellow "INFO: now use \"$output_dir\" as the new output directory, is this ok?"
            _timeout "15"
        fi
}
function _round_stat(){
    local round_stat=$1
    #
    [[ $group_mode == "single" ]] && local g_stat=", GROUP ROUND: $grp_round/$gtotal"
    _yellow "\n$(date "+%Y-%m-%d_%H:%M:%S"): BLK ROUND $bround/$btotal$g_stat, JOB ROUND $job_batch_index/$total_round $round_stat ..."
}
function _execute_job_batch(){
    #local current_host_group=$1
    # $1 host_group_name 
            #send job batchs to host groups
            for job_batch_index in $(seq 1 $total_round) ;do
                # count number and give process info 
                job_batch=${JOB_BATCH_ARRAY[$job_batch_index]}
                # command_mode check 
                [[ $job_batch_index -ge 2 ]] && [[ $command_mode != "always" ]] && CMD=""

                _recover_job_batch

                #exec on all groups
                _round_stat "EXECUTING"
                #print debug 
                _verbose "roundinfo" && _waiting "reading" 5
                if [[ -z $1 ]] && [[ $group_mode == "parallel" ]];then 
                    for host_group_name in $host_group_list ;do
                        _group_execute $host_group_name 
                    done && wait && _blue "round $job_batch_index all jobs distributed."
                else
                    _group_execute $1
                    _blue "round $job_batch_index all jobs distributed."
                fi 

                # check jobs 
                _round_stat "CHECKING"
                _tmp_quiet "on"
                # group mode 
                if [[ -z $1 ]] && [[ $group_mode == "parallel" ]];then 
                    for host_group_name in $host_group_list ;do
                        _group_fio_check $host_group_name 
                        _group_fio_log_harvest $host_group_name 
                    done && wait
                    _blue "###############| Round $job_batch_index ended |################\n"
                else
                    _group_fio_check $1
                    _group_fio_log_harvest $1
                    _blue "###############| Round $job_batch_index ended |################\n"
                fi 
                _tmp_quiet "off"

                # check fio log stat  
                round_report
            done
            #fio jobs distribution done
            # collect logs 
            echo "waiting log collection ..."
            _tmp_quiet "on"
            # scp in background, log harvest in background, check again here
            while ps aux |grep scp |grep -q $output_dir ;do
                sleep 15
            done && wait 
            echo -e "log collection done\n"
}
function _fio_group_report(){
        #build final report of test
        _yellow "\n$(date "+%Y-%m-%d_%H:%M:%S") FIO TEST \"$output_dir\", LOG ANALYSING ..."
        #final_report
        for blk_group_name in $blk_group_list ;do
            # multy blk_group 
            path_flyover=$output_dir 
            [[ $multy_blk_group == "True" ]] && path_flyover+=/$blk_group_name 
            # loop through multy jobgroup 
            if [[ $multy_job_group == "True" ]] ;then 
                for job_group_dir in $(ls $path_flyover/* -d) ;do 
                    bash $(dirname $0)/bin/cfiojobs.log2.sh $job_group_dir
                    [[ $? -ne 0 ]] && _red "dir: \"$job_group_dir\" status abnormal!" 
                done
            else
                bash $(dirname $0)/bin/cfiojobs.log2.sh $path_flyover 
                [[ $? -ne 0 ]] && _red "dir: \"$path_flyover\" status abnormal!" 
            fi
        done
}
function _fio_env_check(){
        _yellow "\n$(date) FIO TEST ENV PRECHECK  ..."
        #network check, software check
        #set blk_group_name empty skip some parse job
        blk_group_name=""
        for host_group_name in $host_group_list;do
            # check host env (recheck after fio package installation)
            _group_pre_check $host_group_name
        done
}

function _fio_conflict_check(){
            #check previous
            _tmp_quiet "on"
            for host_group_name in $host_group_list ;do
                _group_fio_check $host_group_name
            done
            _tmp_quiet "off"
}
function _fio_scale_control(){
            if [[ $group_mode == "single" ]];then 
                grp_round=0
                gtotal=$(echo $host_group_list|wc -w)
                for host_group_name in $host_group_list;do
                    grp_round=$[grp_round +1]
                    [[ $rbd_mode == "True" ]] && _rbd_expansion $host_group_name 
                    _execute_job_batch $host_group_name 
                done
            else
                [[ $rbd_mode == "True" ]] && _rbd_expansion 
                echo "${HOST_GROUP_RBD_DEV_ARRAY[ceph2]}"
                _execute_job_batch 
            fi
}


##############################################################################################
# default blobal options
##############################################################################################
#default options set
function _parameter_set(){

pdebug="False"
conf_check="False"
quiet_mode="False"
list_fio="False"
stop_fio="False"
stop_test="False"
send_fio="False"
host_group_list=""
blk_group_list=""
job_group_list=""
execute_mode="normal"
output_dir=""
test_mode="parallel"
group_mode="parallel"
file_group_list=""
file_group_destination=""
tolerate="False"
p_exec="False"
file_group_list=""
harvest_file_group_list=""
multy_job_group="False"
multy_blk_group="False"
recover_test="False"
recover_blk_group_name=""
recover_job_batch_index=""
command_mode="onece"
rbd_mode="False"
#no_sys_blk="False"

}

function _show_info(){
# print all the user options as a rough debug tool
    if [[ $pdebug == "True" ]] ;then
    _yellow " variable stat "
    _blue "\
##################################
function :${FUNCNAME[@]}
info:
    conf_check: $conf_check
    quiet_mode: $quiet_mode
      list_fio: $list_fio
      stop_fio: $stop_fio
      send_fio: $send_fio
      blk_list: $blk_group_list
      job_list: $job_group_list
     file list: $file_group_list
 harvest_files: $harvest_file_group_list
   destination: $file_group_destination
  execute_mode: $execute_mode
       g group: $host_group_list
       X group: $x_group_list
        x host: $x_host_list
           CMD: $CMD
  command_mode: $command_mode 
    output_dir: $output_dir
  recover_test: $recover_test 
     test_mode: $test_mode
      rbd_mode: $rbd_mode
    group_mode: $group_mode 
    printdebug: $pdebug
      tolerate: $tolerate
     stop_test: $stop_test
##################################"
    #no_sys_blk: $no_sys_blk
_waiting "read info" 10
    [[ -z $host_group_list ]] && _red group empty
                [[ -z $CMD ]] && _red cmd empty
           [[ -z $send_fio ]] && _red send_fio empty
     [[ -z $blk_group_list ]] && _red blk list empty
     [[ -z $job_group_list ]] && _red job list empty
    sleep 2
    fi
}

#############################################################################################
# parameters parse and check, get test arguments info  and command 
#############################################################################################
#options check 
[[ -z $1 ]] &&  _show_help_info && exit 0
_parameter_set
# only individual arguments 
_parse_short_args(){
    #
    while [[ $# -gt 0 ]] ;do
        case "$1" in
            #
        "-t" )
            conf_check="True"
            ;;
        "-c" )
            pre_check="True"
            ;;
        "-q" )
            quiet_mode="True"
            ;;
        "-d" )
            pdebug="True"
            ;;
        "-f" )
            tolerate="True"
            ;;
        "-p" )
            p_exec="True"
            ;;
        "-s" )
            test_mode="single"
            ;;
        "-S" )
            group_mode="single"
            ;;
        "-r" )
            rbd_mode="True"
            ;;
        "-A" )
            execute_mode="After"
            ;;
        "-E" )
            command_mode="always"
            ;;
        * )
            _red "unknown options \"$1\""
            exit 1
            ;;
        esac
        shift 
    done 
}

function _sep_and_parse(){
#    echo "parse: $@"
    while [[ $# -gt 0 ]] ;do
        local alphabet=''
        local args_set=''
        case "$1" in
            "-"* )
                # start with a '-'
                # one letter
                alphabet=${1#*-}
                # one charctor
                if [[ ${#alphabet} -eq 1 ]] ;then 
                    args_set+=' '$1
                    shift 
                    continue
                fi 
                # long combinations of letters 
                # echo all short args : ${#alphabet}
                for i in $(seq 0 $((${#alphabet} -1)) );do 
                    #echo $i -${alphabet:$i:1}
                    args_set+=' -'${alphabet:$i:1}
                    #echo reparse ${alphabet:$i:1}
                done
                ;;
            * )
                # not start with a '-'
                echo "format error: $1 is not an argument!"
                exit 1
                ;;
        esac
        shift
    done
    # do not quote the args set .
    _parse_short_args $args_set
}

#check option calculating result
while [ $# -gt 0 ] ;do
    case "$1" in
        "-a" )
            _get_all_host_group
            ;;
        "-g" )
            if [ $# -lt 2 ]
            then
                echo "$0: -g requires a groupname or group list. multi names separated by comma."
                STATUS=1
                exit
            fi
            host_group_list+=" ${2//,/ }"
            shift
            ;;
        "-x" )
            if [ $# -lt 2 ]
            then
                echo "$0: -x requires a hostname or host/ip list. multi names separated by comma."
                STATUS=1
                exit
            fi
            x_host_list+=" ${2//,/ }"
            shift
            ;;
        "-X" )
            if [ $# -lt 2 ]
            then
                echo "$0: -X requires a groupname or group list.  multi names separated by comma."
                STATUS=1
                exit
            fi
            #there will be a uniq element check, so redundant delimiter is fine here
            x_group_list+=" ${2//,/ }"
            shift
            ;;
        "--fio-list" )
            list_fio="True"
            ;;
        "--fio-stop" )
            stop_fio="True"
            ;;
        "--test-stop" )
            stop_test="True"
            ;;
        "--fio" )
            send_fio="True"
            ;;
        "--recover" )
            recover_test="True"
            ;;
        "--recover-from" )
            if [ $# -lt 2 ]
            then
                echo "$0: --recover-from requires a Round Number at least"
                STATUS=1
                exit
            fi
            recover_test="True"
            [[ ${2//,/} != ${2} ]] && recover_blk_group_name=${2%,*}
            recover_job_batch_index=${2##*,}
            shift
            ;;
        "--round-list" )
            round_list="True"
            ;;
        "--round-retest" )
            if [ $# -lt 2 ]
            then
                echo "$0: --round-retest requires a Round Number at least"
                STATUS=1
                exit
            fi
            round_retest="True"
            [[ ${2//,/} != ${2} ]] && recover_blk_group_name=${2%,*}
            recover_job_batch_index=${2##*,}
            shift
            ;;
        "-b" )
            if [ $# -lt 2 ]
            then
                echo "$0: -b requires a blk/file group name or a list of that.  multi names separated by comma."
                STATUS=1
                exit
            fi
            blk_group_list+=" ${2//,/ }"
            shift
            ;;
        "-j" )
            if [ $# -lt 2 ]
            then
                echo "$0: -j requires a job group name or a job group list.  multi names separated by comma."
                STATUS=1
                exit
            fi
            job_group_list+=" ${2//,/ }"
            shift
            ;;
        "-o" )
            if [ $# -lt 2 ]
            then
                echo "$0: -o requires an output directory to work."
                STATUS=1
                exit
            fi
            #remove the last "/"
            if [[ ${2:0-1:1} == / ]] 
            then
                output_dir="${2%/*}"
            else
                output_dir="$2"
            fi
            shift
            ;;
        "-l" )
            _list_all_running_jobs
            exit
            ;;
        #"--no-sys" )
        #    no_sys_blk="True"
        #    ;;
        "-F" )
            if [ $# -lt 2 ]
            then
                echo "$0: -F requires a file list.  multi names separated by comma."
                STATUS=1
                exit
            fi
            file_group_list+=" ${2//,/ }"
            shift
            ;;
        "-C" )
            if [ $# -lt 2 ]
            then
                echo "$0: -C requires a file list.  multi names separated by comma."
                STATUS=1
                exit
            fi
            harvest_file_group_list+="${2}"
            shift
            ;;
        "-D" )
            if [ $# -lt 2 ]
            then
                echo "$0: -D requires an output directory to work."
                STATUS=1
                exit
            fi
            #remove the last "/"
            if [[ ${2:0-1:1} == / ]] 
            then
                file_group_destination="${2%/*}"
            else
                file_group_destination="$2"
            fi
            shift
            ;;
        "-h" )
            _show_help_info
            exit 0
            ;;
        "-e" )
            _make_conf_example
            exit 0
            ;;
        "-v"|"--version" )
            echo "$0 $script_version"
            exit 0
            ;;
        * )
            # one word or start with '-'
            if [[ $(echo $1|wc -w) -gt 1 ]] || [[ ${1:0:1} != '-'  ]] ;then 
                #cmd none empty test is needed
                [[ -z $CMD ]] && CMD="$1" || CMD+=" $1"
            else  
                _sep_and_parse "$1"
            fi 
            ;;
    esac
    shift
done


#############################################################################################
# configure file and input options check
#############################################################################################
# after this stage:
# 1. host/blk/job groups are checked.
# 2. usefull inof stored in array.
#running options check
    _show_info
    if [[ $conf_check == "True" ]] ;then 
        _grp_conf_check
        _blk_conf_check
        _job_conf_check
    fi
# check blk group, exit with any wrong name, '-d' skip missing group
        _host_group_check
        #preparation before send fio jobs
        if [[ $send_fio == "True" ]] ;then
            _blk_group_check
            _job_group_check
            _recover_point_check
        else
            #stop job expansion
            blk_stat=2
            job_stat=2
        fi
# confirm blk_stat/grp_stat/job_stat, 0:ok, 1:part failed, 2:all failed.
        if [[ $blk_stat -lt 2 ]] && \
           [[ $job_stat -lt 2 ]] && \
           [[ $grp_stat -lt 2 ]] 
        then
            #job preparation
            _fio_job_expansion
        fi

#############################################################################################
# execute command or start fio test on specified host/blk/job groups
#############################################################################################
# some actions don't need a blk group target.
    # stop fio, list fio, run cmd 
# actions acquire a blk target.
    # send fio



# stop jobs of job round running.
    if [[ $pre_check == "True" ]] ;then
        echo "start env precheck ..."
        for host_group_name in $host_group_list ;do
            _group_pre_check $host_group_name
            _group_blk_detect $host_group_name
            _group_blk_precheck $host_group_name 
        done
# stop jobs of job round running.
    elif [[ $stop_fio == "True" ]] ;then
        echo "stop fio jobs ..."
        for host_group_name in $host_group_list ;do
            _group_fio_stop $host_group_name
        done
# stop test.
    elif [[ $stop_test == "True" ]] ;then
        echo "stop fio test ..."
        for host_group_name in $host_group_list ;do
            _group_test_stop $host_group_name
        done
# list jobs
    elif [[ $list_fio == "True" ]] ;then
        #
        for host_group_name in $host_group_list ;do
            _group_fio_list $host_group_name
        done
# send files, jobs and cmd
    elif [[ $send_fio == "True" ]] ;then

        #check output directory, set default to a datatime stamp.
        _check_output_dir 
        #check test env for all host groups, fio installation, network reachability, ssh access.
        _fio_env_check 
 
        #send jobs with available blk group
        broud=0
        btotal=$(echo $blk_group_list |wc -w)
        for blk_group_name in $blk_group_list ;do
            bround=$[bround+1]

            # blk group ( round one) info befor start job batch 
            _yellow "\n$(date "+%Y-%m-%d_%H:%M:%S") FIO TEST BLK GROUP: $blk_group_name, PREPARING ..."
            #
            echo -e  "block device group: $(_yellow "$blk_group_name")" 
            _unquiet "dev list : ${BLK_DEV_ARRAY[$blk_group_name]}\n" || echo ""

            _recover_blk_group

            _fio_conflict_check 
            # control group scale and start test on host groups 
            _fio_scale_control 

        done
        #blk group

        # cleanning recover log when test is done 
        rm -f $output_dir/recover.log  
        rm -f $tmpfile_exec_out 
        _fio_group_report 

        # end info
        _yellow "\n$(date "+%Y-%m-%d_%H:%M:%S") FIO TEST FINISHED."

# send files and cmd
    elif [[ -n $CMD ]] || [[ -n $file_group_list ]] || [[ -n $harvest_file_group_list ]] ;then
        # check outputdir 
        [[ -n $harvest_file_group_list  ]] &&  _check_output_dir 
        # run on group 
        for host_group_name in $host_group_list ;do
            # info 
            [[ -n $CMD ]] && _yellow "command: \"$CMD\"\n"
            [[ -n $file_group_list ]] && _yellow "  send files: \"$file_group_list\""
            [[ -n $harvest_file_group_list ]] && _yellow "  harvest files: \"$harvest_file_group_list\""
            # execute 
            _group_execute $host_group_name
        done
        # cleanning 
        rm -f $tmpfile_exec_out 
    else 
        _yellow "imcomplete agrs recived, nothing to do."
    fi

#############################################################################################
# how the blk/job/host groups works in this script.
#############################################################################################
# 1. blk_group_name(str)/job_batch(int) will be checked first in the main script,
#    most functions need all blk/job/host info when they were called.
#    fio related functions called by host_group_name,
#    all host group info were stored in a series array like: HOST_GROUP_XXX_ARRAY[host_group_name].
#
# 2. after job batch expansion, all job group info will be contained in a index ARRAY: JOB_BATCH_ARRAY[index]
#
# 3. job_group_name can be regained from JOB_BATCH_NAME_ARRAY[index].
#
# 4. how these info were ognaized
#    blk_group_list   --> each one blk_group_name               --> its blk_list
#    job_group_list   --> each one job_group_name :bs*pattern   --> its job args assemblage
#    host_group_list  --> each one host_group_name              --> its ip_list
#
# 5. how the process sequnce was set.
#       --> blk group(device scale) 
#       --> job batch(bs*pattern*args) --> single job command (test pattern and mode control)
#                                      --> host group (user,port,ip_list;backend server info)  --> single host (run the test)
#    A host in host group will recive :
#      1). file list (-F xxx,xxx -D xxx)
#      2). device list: fio job arguments list (bs + pattern + other arg set of a job group)
#      3). a command list, and these commands will be executed along with the fio jobs.
#############################################################################################
